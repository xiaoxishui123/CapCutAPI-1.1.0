# 自定义下载功能逻辑问题分析报告

## 📋 检查日期
2025-11-01

## 🔍 功能流程分析

### 当前实现流程

1. **前端调用** (`preview.html`)
   - 用户点击 "📦 自定义下载" 按钮
   - 触发函数：`startCustomDownload(draftId)`
   - API调用：`POST /api/draft/download`
   - 请求参数：
     ```javascript
     {
       draft_id: draftId,
       use_custom_path: true,
       draft_folder: customPath  // 从配置中获取
     }
     ```

2. **后端处理** (`capcut_server.py`)
   - 路由：`/api/draft/download` (第3260行)
   - 函数：`draft_download_api()`
   - 调用：`get_customized_signed_url(draft_id, client_os, draft_folder)`
   - 返回：代理下载URL

3. **自定义ZIP生成** (`customize_zip.py`)
   - 函数：`ensure_customized_zip()`
   - 流程：
     - 检查OSS上是否存在自定义版本（基于client_os和draft_folder的哈希）
     - 如不存在，下载基础ZIP
     - 修改`draft_info.json`中的路径
     - 重新打包并上传到OSS

## ❌ 发现的问题

### 问题1：代理URL缺少必要参数 ⚠️ **严重**

**位置**：`capcut_server.py` 第3293行

**问题代码**：
```python
proxy_download_url = f"/api/draft/download/proxy/{draft_id}"
return jsonify({
    'success': True,
    'download_url': proxy_download_url,  # 缺少参数！
    'original_url': custom_download_url,
    ...
})
```

**问题描述**：
- 代理URL没有包含 `client_os` 和 `draft_folder` 参数
- 代理处理器（第3730-3731行）期望从查询参数获取这些值：
  ```python
  client_os = request.args.get('client_os', 'windows')
  draft_folder = request.args.get('draft_folder', '')
  ```
- 如果缺少这些参数，代理会使用默认值，可能生成错误的自定义ZIP

**影响**：
- 如果用户配置的路径与配置文件中不同，会下载到错误的自定义版本
- 可能导致路径不匹配，剪映无法识别素材

**修复方案**：
```python
# 应该改为：
from urllib.parse import urlencode
params = urlencode({
    'client_os': client_os,
    'draft_folder': draft_folder
})
proxy_download_url = f"/api/draft/download/proxy/{draft_id}?{params}"
```

---

### 问题2：路径配置验证不完整 ⚠️ **中等**

**位置**：`capcut_server.py` 第3202行

**问题代码**：
```python
try:
    os.makedirs(custom_path, exist_ok=True)
except Exception as e:
    return jsonify({
        'success': False,
        'error': f'无法创建或访问路径: {str(e)}'
    }), 400
```

**问题描述**：
- 在Linux服务器上验证Windows路径（如 `F:\jianying\cgwz\JianyingPro Drafts`）
- Linux无法创建Windows盘符路径，会导致配置失败
- 用户无法设置Windows路径

**影响**：
- 用户在配置Windows路径时会收到错误
- 无法正确配置跨平台路径

**修复方案**：
```python
# 应该跳过跨平台路径的物理验证
def is_cross_platform_path(path, client_os):
    """检查是否为跨平台路径"""
    if client_os == 'windows':
        # Windows路径特征：盘符开头
        return bool(re.match(r'^[A-Za-z]:\\', path))
    return False

# 在验证逻辑中：
if custom_path:
    # 检测客户端操作系统
    client_os = data.get('client_os', 'windows')
    
    # 如果是跨平台路径，跳过物理验证
    if not is_cross_platform_path(custom_path, client_os):
        try:
            os.makedirs(custom_path, exist_ok=True)
        except Exception as e:
            return jsonify({
                'success': False,
                'error': f'无法创建或访问路径: {str(e)}'
            }), 400
```

---

### 问题3：存在未使用的重复函数 ⚠️ **低**

**位置**：`preview.html` 第1561行

**问题描述**：
- 存在两个类似的下载函数：
  1. `customPathDownload()` - 调用 `/api/drafts/download/custom/<draft_id>`
  2. `startCustomDownload()` - 调用 `/api/draft/download` ✅ **实际使用**
- `customPathDownload()` 未被HTML按钮调用，属于死代码

**影响**：
- 代码冗余，增加维护成本
- 可能引起混淆

**修复方案**：
- 删除未使用的 `customPathDownload()` 函数
- 保留并优化 `startCustomDownload()` 函数

---

### 问题4：前端缺少client_os参数传递 ⚠️ **中等**

**位置**：`preview.html` 第1878-1882行

**问题代码**：
```javascript
body: JSON.stringify({
    draft_id: draftId,
    use_custom_path: true,
    draft_folder: customPath
    // 缺少 client_os！
})
```

**问题描述**：
- 前端调用下载API时，没有传递 `client_os` 参数
- 后端使用默认值 `'unknown'`（第3267行）
- 可能导致生成的自定义ZIP不包含正确的操作系统路径格式

**修复方案**：
```javascript
// 在请求体中添加 client_os
const clientOS = detectClientOS();  // 这个函数已存在
body: JSON.stringify({
    draft_id: draftId,
    use_custom_path: true,
    draft_folder: customPath,
    client_os: clientOS  // 添加此参数
})
```

---

### 问题5：前端路径配置缺少client_os ⚠️ **中等**

**位置**：`preview.html` 第1698-1705行

**问题代码**：
```javascript
fetch('/api/draft/path/config', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        custom_path: newPath
        // 缺少 client_os！
    })
})
```

**问题描述**：
- 配置路径时没有告知服务器客户端操作系统
- 服务器无法进行正确的路径格式验证
- 后端第3202行的路径验证会失败（见问题2）

**修复方案**：
```javascript
const clientOS = detectClientOS();
body: JSON.stringify({
    custom_path: newPath,
    client_os: clientOS  // 添加此参数
})
```

---

## ✅ 正确运行的部分

### 1. 自定义ZIP生成逻辑 ✓
- `customize_zip.py` 的路径重写逻辑正确
- `_rewrite_paths_in_json()` 函数能正确处理嵌套路径
- `normalize_path_by_os()` 能正确转换路径格式

### 2. OSS缓存机制 ✓
- 使用哈希值避免重复生成相同配置的ZIP
- `ensure_customized_zip()` 检查已存在的自定义版本

### 3. 前端路径显示和更新 ✓
- `loadCurrentPathConfig()` 正确加载配置
- `updatePathDisplay()` 正确更新显示

---

## 🔧 推荐的修复优先级

### 高优先级（必须修复）
1. **修复代理URL参数传递**（问题1）
2. **添加client_os参数到前端请求**（问题4、5）

### 中优先级（建议修复）
3. **改进跨平台路径验证**（问题2）
4. **清理未使用的代码**（问题3）

### 低优先级（优化）
5. 添加更详细的错误日志
6. 添加下载进度跟踪
7. 增强用户体验提示

---

## 📝 测试建议

### 测试场景1：Windows用户配置路径
1. 在Windows浏览器中打开预览页面
2. 配置路径：`F:\jianying\cgwz\JianyingPro Drafts`
3. 点击"自定义下载"
4. 验证下载的ZIP包含正确的Windows路径

### 测试场景2：Linux用户配置路径
1. 在Linux浏览器中打开预览页面
2. 配置路径：`/home/user/JianyingPro Drafts`
3. 点击"自定义下载"
4. 验证下载的ZIP包含正确的Linux路径

### 测试场景3：路径切换
1. 先配置路径A并下载
2. 修改为路径B并下载
3. 验证两次下载使用了不同的自定义ZIP

---

## 💡 总结

**总体评价**：功能设计思路正确，但在参数传递和跨平台支持方面存在缺陷。

**核心问题**：
- 参数传递链不完整（前端→后端→代理）
- 跨平台路径验证逻辑不合理

**修复后的预期效果**：
- 用户可以在任何操作系统的浏览器中配置目标路径
- 下载的ZIP包含正确的客户端路径格式
- 剪映能够自动识别所有素材，无需手动重新链接

