app:
  description: "åŸºäºMCP Bridgeçš„æ™ºèƒ½çŸ­è§†é¢‘ç”Ÿæˆå·¥ä½œæµ - ä¼˜åŒ–ç‰ˆ"
  icon: "ğŸ¬"
  icon_background: "#FF6B6B"
  mode: workflow
  name: "æ™ºèƒ½çŸ­è§†é¢‘ç”Ÿæˆå™¨ v2.0"

kind: app
version: 0.1.2

workflow:
  conversation_variables: []
  environment_variables:
    - name: MCP_BRIDGE_URL
      value: "http://localhost:8082"
    - name: CAPCUT_API_URL  
      value: "http://localhost:9000"
    - name: ENABLE_HTTP_FALLBACK
      value: "true"
    - name: MAX_RETRY_COUNT
      value: "3"
    - name: RENDER_TIMEOUT
      value: "300"

  graph:
    edges:
      # ä¸»æµç¨‹è¾¹
      - id: start-to-validate
        source: start
        target: validate_input
      - id: validate-to-script
        source: validate_input
        target: generate_script
      - id: script-to-parallel
        source: generate_script
        target: parallel_materials
      - id: parallel-to-draft
        source: parallel_materials
        target: create_draft
      - id: draft-to-assembly
        source: create_draft
        target: timeline_assembly
      - id: assembly-to-audio
        source: timeline_assembly
        target: audio_mixing
      - id: audio-to-subtitle
        source: audio_mixing
        target: subtitle_alignment
      - id: subtitle-to-render
        source: subtitle_alignment
        target: submit_render
      - id: render-to-monitor
        source: submit_render
        target: monitor_progress
      - id: monitor-to-end
        source: monitor_progress
        target: end

    nodes:
      # èŠ‚ç‚¹1: å¼€å§‹èŠ‚ç‚¹ - ç”¨æˆ·è¾“å…¥éªŒè¯
      - data:
          desc: "ç”¨æˆ·è¾“å…¥å‚æ•°éªŒè¯å’Œé»˜è®¤å€¼è®¾ç½®"
          selected: false
          title: "ç”¨æˆ·è¾“å…¥éªŒè¯"
          type: start
          variables:
            - label: "è§†é¢‘ä¸»é¢˜"
              max_length: 200
              options: []
              required: true
              type: text-input
              variable: video_topic
            - label: "è§†é¢‘æ—¶é•¿(ç§’)"
              max_length: 10
              options: []
              required: false
              type: number-input
              variable: video_duration
              default: 30
            - label: "è§†é¢‘é£æ ¼"
              options:
                - "ç°ä»£ç®€çº¦"
                - "å•†åŠ¡ä¸“ä¸š"
                - "æ—¶å°šæ½®æµ"
                - "æ•™è‚²ç§‘æ™®"
                - "è¥é”€æ¨å¹¿"
              required: false
              type: select
              variable: video_style
              default: "ç°ä»£ç®€çº¦"
            - label: "è§†é¢‘æ¯”ä¾‹"
              options:
                - "9:16"
                - "16:9"
                - "1:1"
              required: false
              type: select
              variable: video_ratio
              default: "9:16"
            - label: "å¯ç”¨å­—å¹•"
              required: false
              type: boolean
              variable: enable_subtitle
              default: true
            - label: "å¯ç”¨èƒŒæ™¯éŸ³ä¹"
              required: false
              type: boolean
              variable: enable_bgm
              default: true
        height: 90
        id: start
        position:
          x: 80
          y: 282
        positionAbsolute:
          x: 80
          y: 282
        selected: false
        type: start
        width: 244

      # èŠ‚ç‚¹2: å‚æ•°éªŒè¯å’Œé¢„å¤„ç†
      - data:
          code: |
            import json
            
            def main(video_topic: str, video_duration: int = 30, video_style: str = "ç°ä»£ç®€çº¦", 
                    video_ratio: str = "9:16", enable_subtitle: bool = True, enable_bgm: bool = True) -> dict:
                """
                ç”¨æˆ·è¾“å…¥å‚æ•°éªŒè¯å’Œé¢„å¤„ç†
                """
                # å‚æ•°éªŒè¯
                if not video_topic or len(video_topic.strip()) < 5:
                    raise ValueError("è§†é¢‘ä¸»é¢˜ä¸èƒ½å°‘äº5ä¸ªå­—ç¬¦")
                
                if video_duration < 15 or video_duration > 300:
                    raise ValueError("è§†é¢‘æ—¶é•¿å¿…é¡»åœ¨15-300ç§’ä¹‹é—´")
                
                # æ ¹æ®æ¯”ä¾‹è®¾ç½®åˆ†è¾¨ç‡
                resolution_map = {
                    "9:16": {"width": 1080, "height": 1920},
                    "16:9": {"width": 1920, "height": 1080}, 
                    "1:1": {"width": 1080, "height": 1080}
                }
                
                resolution = resolution_map.get(video_ratio, {"width": 1080, "height": 1920})
                
                # æ„å»ºéªŒè¯åçš„å‚æ•°
                validated_params = {
                    "video_topic": video_topic.strip(),
                    "video_duration": video_duration,
                    "video_style": video_style,
                    "video_ratio": video_ratio,
                    "video_width": resolution["width"],
                    "video_height": resolution["height"],
                    "enable_subtitle": enable_subtitle,
                    "enable_bgm": enable_bgm,
                    "timestamp": int(time.time())
                }
                
                return {
                    "validated_params": json.dumps(validated_params),
                    "video_width": resolution["width"],
                    "video_height": resolution["height"]
                }
          desc: "éªŒè¯ç”¨æˆ·è¾“å…¥å‚æ•°å¹¶è®¾ç½®é»˜è®¤å€¼"
          outputs:
            validated_params:
              type: string
            video_width:
              type: number
            video_height:
              type: number
          selected: false
          title: "å‚æ•°éªŒè¯"
          type: code
          variables:
            - value_selector:
                - start
                - video_topic
              variable: video_topic
            - value_selector:
                - start
                - video_duration
              variable: video_duration
            - value_selector:
                - start
                - video_style
              variable: video_style
            - value_selector:
                - start
                - video_ratio
              variable: video_ratio
            - value_selector:
                - start
                - enable_subtitle
              variable: enable_subtitle
            - value_selector:
                - start
                - enable_bgm
              variable: enable_bgm
        height: 54
        id: validate_input
        position:
          x: 384
          y: 282
        positionAbsolute:
          x: 384
          y: 282
        selected: false
        type: code
        width: 244

      # èŠ‚ç‚¹3: å†…å®¹è„šæœ¬ç”Ÿæˆ
      - data:
          context:
            enabled: false
            variable_selector: []
          desc: "åŸºäºç”¨æˆ·ä¸»é¢˜ç”Ÿæˆç»“æ„åŒ–è§†é¢‘è„šæœ¬"
          model:
            completion_params:
              temperature: 0.7
            mode: chat
            name: doubao-pro-32k
            provider: volcengine_maas
          prompt_template:
            - id: system
              role: system
              text: |
                ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„çŸ­è§†é¢‘è„šæœ¬åˆ›ä½œä¸“å®¶ã€‚è¯·åŸºäºç”¨æˆ·æä¾›çš„ä¸»é¢˜å’Œå‚æ•°ï¼Œç”Ÿæˆä¸€ä¸ªç»“æ„åŒ–çš„è§†é¢‘è„šæœ¬ã€‚

                è¦æ±‚ï¼š
                1. è„šæœ¬å¿…é¡»ç¬¦åˆæŒ‡å®šçš„æ—¶é•¿å’Œé£æ ¼
                2. å†…å®¹è¦æœ‰å¸å¼•åŠ›ï¼Œé€‚åˆçŸ­è§†é¢‘ä¼ æ’­
                3. åœºæ™¯åˆ’åˆ†è¦åˆç†ï¼Œæ¯ä¸ªåœºæ™¯3-8ç§’
                4. åŒ…å«è§†è§‰æè¿°ï¼Œä¾¿äºåç»­ç´ æç”Ÿæˆ

                è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼š
                {
                  "title": "è§†é¢‘æ ‡é¢˜",
                  "description": "è§†é¢‘æè¿°",
                  "total_duration": 30,
                  "scenes": [
                    {
                      "id": 1,
                      "text": "åœºæ™¯æ–‡å­—å†…å®¹",
                      "duration": 5,
                      "visual_description": "è§†è§‰åœºæ™¯æè¿°",
                      "text_style": "å­—ä½“æ ·å¼å»ºè®®",
                      "transition": "è½¬åœºæ•ˆæœ"
                    }
                  ],
                  "bgm_style": "èƒŒæ™¯éŸ³ä¹é£æ ¼",
                  "voice_style": "æ—ç™½é£æ ¼"
                }
            - id: user
              role: user
              text: |
                è¯·ä¸ºä»¥ä¸‹ä¸»é¢˜ç”ŸæˆçŸ­è§†é¢‘è„šæœ¬ï¼š

                ä¸»é¢˜ï¼š{{#validated_params.video_topic#}}
                æ—¶é•¿ï¼š{{#validated_params.video_duration#}}ç§’
                é£æ ¼ï¼š{{#validated_params.video_style#}}
                æ¯”ä¾‹ï¼š{{#validated_params.video_ratio#}}

                è¯·ç¡®ä¿å†…å®¹æœ‰è¶£ã€å¸å¼•äººï¼Œé€‚åˆ{{#validated_params.video_style#}}é£æ ¼ã€‚
          selected: false
          title: "è„šæœ¬ç”Ÿæˆ"
          type: llm
          variables:
            - value_selector:
                - validate_input
                - validated_params
              variable: validated_params
          vision:
            enabled: false
        height: 98
        id: generate_script
        position:
          x: 688
          y: 282
        positionAbsolute:
          x: 688
          y: 282
        selected: false
        type: llm
        width: 244

      # èŠ‚ç‚¹4: å¹¶è¡Œç´ æç”Ÿæˆ
      - data:
          desc: "å¹¶è¡Œç”ŸæˆTTSã€å­—å¹•ã€BGMå’Œè§†è§‰ç´ æ"
          selected: false
          title: "å¹¶è¡Œç´ æç”Ÿæˆ"
          type: parallel
          branches:
            # åˆ†æ”¯1: TTSè¯­éŸ³åˆæˆ
            - id: tts_branch
              name: "TTSè¯­éŸ³åˆæˆ"
              nodes:
                - data:
                    code: |
                      import json
                      import requests
                      import time
                      
                      def main(video_script: str, validated_params: str) -> dict:
                          """
                          TTSè¯­éŸ³åˆæˆå¤„ç†
                          """
                          try:
                              script_data = json.loads(video_script)
                              params_data = json.loads(validated_params)
                              
                              # æå–æ‰€æœ‰åœºæ™¯æ–‡å­—
                              all_text = []
                              for scene in script_data.get("scenes", []):
                                  all_text.append(scene.get("text", ""))
                              
                              full_text = " ".join(all_text)
                              
                              # è°ƒç”¨TTSæœåŠ¡ (è¿™é‡Œéœ€è¦æ ¹æ®å®é™…TTSæœåŠ¡è°ƒæ•´)
                              tts_result = {
                                  "audio_url": f"/tmp/tts_audio_{int(time.time())}.mp3",
                                  "duration": params_data.get("video_duration", 30),
                                  "text": full_text,
                                  "voice_style": script_data.get("voice_style", "æ ‡å‡†å¥³å£°")
                              }
                              
                              return {
                                  "tts_result": json.dumps(tts_result),
                                  "audio_duration": tts_result["duration"]
                              }
                          except Exception as e:
                              return {
                                  "tts_result": json.dumps({"error": str(e)}),
                                  "audio_duration": 0
                              }
                    outputs:
                      tts_result:
                        type: string
                      audio_duration:
                        type: number
                    title: "TTSåˆæˆ"
                    type: code
                    variables:
                      - value_selector:
                          - generate_script
                          - text
                        variable: video_script
                      - value_selector:
                          - validate_input
                          - validated_params
                        variable: validated_params

            # åˆ†æ”¯2: å­—å¹•ç”Ÿæˆ
            - id: subtitle_branch
              name: "å­—å¹•ç”Ÿæˆ"
              nodes:
                - data:
                    code: |
                      import json
                      import time
                      
                      def main(video_script: str, validated_params: str) -> dict:
                          """
                          ç”ŸæˆSRTæ ¼å¼å­—å¹•æ–‡ä»¶
                          """
                          try:
                              script_data = json.loads(video_script)
                              params_data = json.loads(validated_params)
                              
                              subtitles = []
                              current_time = 0
                              
                              for i, scene in enumerate(script_data.get("scenes", [])):
                                  start_time = current_time
                                  duration = scene.get("duration", 5)
                                  end_time = start_time + duration
                                  
                                  subtitle = {
                                      "index": i + 1,
                                      "start_time": start_time,
                                      "end_time": end_time,
                                      "text": scene.get("text", ""),
                                      "style": scene.get("text_style", "é»˜è®¤")
                                  }
                                  subtitles.append(subtitle)
                                  current_time = end_time
                              
                              subtitle_result = {
                                  "subtitle_file": f"/tmp/subtitle_{int(time.time())}.srt",
                                  "subtitles": subtitles,
                                  "total_duration": current_time
                              }
                              
                              return {
                                  "subtitle_result": json.dumps(subtitle_result)
                              }
                          except Exception as e:
                              return {
                                  "subtitle_result": json.dumps({"error": str(e)})
                              }
                    outputs:
                      subtitle_result:
                        type: string
                    title: "å­—å¹•ç”Ÿæˆ"
                    type: code
                    variables:
                      - value_selector:
                          - generate_script
                          - text
                        variable: video_script
                      - value_selector:
                          - validate_input
                          - validated_params
                        variable: validated_params

            # åˆ†æ”¯3: BGMæœç´¢
            - id: bgm_branch
              name: "BGMæœç´¢"
              nodes:
                - data:
                    code: |
                      import json
                      import time
                      
                      def main(video_script: str, validated_params: str) -> dict:
                          """
                          BGMæœç´¢å’Œå‡†å¤‡
                          """
                          try:
                              script_data = json.loads(video_script)
                              params_data = json.loads(validated_params)
                              
                              # æ ¹æ®è„šæœ¬é£æ ¼é€‰æ‹©BGM
                              bgm_style = script_data.get("bgm_style", "è½»æ¾æ„‰å¿«")
                              video_style = params_data.get("video_style", "ç°ä»£ç®€çº¦")
                              
                              # BGMæœç´¢é€»è¾‘ (è¿™é‡Œéœ€è¦æ ¹æ®å®é™…BGMæœåŠ¡è°ƒæ•´)
                              bgm_result = {
                                  "bgm_url": f"/tmp/bgm_{int(time.time())}.mp3",
                                  "bgm_style": bgm_style,
                                  "duration": params_data.get("video_duration", 30),
                                  "volume": 0.3,  # èƒŒæ™¯éŸ³ä¹éŸ³é‡
                                  "fade_in": 2,    # æ·¡å…¥æ—¶é—´
                                  "fade_out": 2    # æ·¡å‡ºæ—¶é—´
                              }
                              
                              return {
                                  "bgm_result": json.dumps(bgm_result)
                              }
                          except Exception as e:
                              return {
                                  "bgm_result": json.dumps({"error": str(e)})
                              }
                    outputs:
                      bgm_result:
                        type: string
                    title: "BGMæœç´¢"
                    type: code
                    variables:
                      - value_selector:
                          - generate_script
                          - text
                        variable: video_script
                      - value_selector:
                          - validate_input
                          - validated_params
                        variable: validated_params

            # åˆ†æ”¯4: è§†è§‰ç´ æç”Ÿæˆ
            - id: visual_branch
              name: "è§†è§‰ç´ æç”Ÿæˆ"
              nodes:
                - data:
                    code: |
                      import json
                      import time
                      
                      def main(video_script: str, validated_params: str) -> dict:
                          """
                          è§†è§‰ç´ æç”Ÿæˆ (æ–‡ç”Ÿå›¾/æ–‡ç”Ÿè§†é¢‘)
                          """
                          try:
                              script_data = json.loads(video_script)
                              params_data = json.loads(validated_params)
                              
                              visual_materials = []
                              
                              for i, scene in enumerate(script_data.get("scenes", [])):
                                  visual_desc = scene.get("visual_description", "")
                                  
                                  # è¿™é‡Œéœ€è¦è°ƒç”¨å®é™…çš„AIç”ŸæˆæœåŠ¡
                                  material = {
                                      "scene_id": i + 1,
                                      "type": "image",  # æˆ– "video"
                                      "url": f"/tmp/visual_{i+1}_{int(time.time())}.jpg",
                                      "description": visual_desc,
                                      "duration": scene.get("duration", 5)
                                  }
                                  visual_materials.append(material)
                              
                              visual_result = {
                                  "materials": visual_materials,
                                  "total_count": len(visual_materials)
                              }
                              
                              return {
                                  "visual_result": json.dumps(visual_result)
                              }
                          except Exception as e:
                              return {
                                  "visual_result": json.dumps({"error": str(e)})
                              }
                    outputs:
                      visual_result:
                        type: string
                    title: "è§†è§‰ç´ æç”Ÿæˆ"
                    type: code
                    variables:
                      - value_selector:
                          - generate_script
                          - text
                        variable: video_script
                      - value_selector:
                          - validate_input
                          - validated_params
                        variable: validated_params
        height: 54
        id: parallel_materials
        position:
          x: 992
          y: 282
        positionAbsolute:
          x: 992
          y: 282
        selected: false
        type: parallel
        width: 244

      # èŠ‚ç‚¹5: MCPè‰ç¨¿åˆ›å»º
      - data:
          desc: "ä½¿ç”¨MCP Bridgeåˆ›å»ºCapCutè‰ç¨¿é¡¹ç›®"
          selected: false
          title: "åˆ›å»ºè‰ç¨¿"
          type: tool
          provider_id: capcut-mcp-bridge
          provider_type: builtin
          tool_name: create_draft
          tool_parameters:
            title:
              type: mixed
              value: "{{#generate_script.text#}}"
            width:
              type: mixed
              value: "{{#validate_input.video_width#}}"
            height:
              type: mixed
              value: "{{#validate_input.video_height#}}"
        height: 54
        id: create_draft
        position:
          x: 1296
          y: 282
        positionAbsolute:
          x: 1296
          y: 282
        selected: false
        type: tool
        width: 244

      # èŠ‚ç‚¹6: æ—¶é—´è½´è£…é…
      - data:
          code: |
            import json
            import requests
            import os
            
            def main(draft_result: str, tts_result: str, visual_result: str, 
                    subtitle_result: str, bgm_result: str, validated_params: str) -> dict:
                """
                æ—¶é—´è½´è£…é… - ä½¿ç”¨MCP Bridgeæ‰¹é‡æ“ä½œ
                """
                try:
                    # è§£ææ‰€æœ‰è¾“å…¥æ•°æ®
                    draft_data = json.loads(draft_result)
                    tts_data = json.loads(tts_result)
                    visual_data = json.loads(visual_result)
                    subtitle_data = json.loads(subtitle_result)
                    bgm_data = json.loads(bgm_result)
                    params_data = json.loads(validated_params)
                    
                    draft_id = draft_data.get("draft_id")
                    if not draft_id:
                        raise ValueError("è‰ç¨¿IDä¸å­˜åœ¨")
                    
                    # MCP Bridge URL
                    mcp_url = os.getenv("MCP_BRIDGE_URL", "http://localhost:8082")
                    
                    # æ‰¹é‡æ·»åŠ ç´ æçš„æ“ä½œåˆ—è¡¨
                    operations = []
                    
                    # 1. æ·»åŠ è§†è§‰ç´ æ
                    current_time = 0
                    for material in visual_data.get("materials", []):
                        if material.get("type") == "image":
                            operations.append({
                                "operation": "add_image",
                                "params": {
                                    "draft_id": draft_id,
                                    "image_path": material.get("url"),
                                    "start_time": current_time,
                                    "duration": material.get("duration", 5)
                                }
                            })
                        elif material.get("type") == "video":
                            operations.append({
                                "operation": "add_video", 
                                "params": {
                                    "draft_id": draft_id,
                                    "video_path": material.get("url"),
                                    "start_time": current_time,
                                    "duration": material.get("duration", 5)
                                }
                            })
                        current_time += material.get("duration", 5)
                    
                    # 2. æ·»åŠ éŸ³é¢‘è½¨é“ (TTSä¸ºä¸»æ—¶é’Ÿ)
                    if not tts_data.get("error"):
                        operations.append({
                            "operation": "add_audio",
                            "params": {
                                "draft_id": draft_id,
                                "audio_path": tts_data.get("audio_url"),
                                "start_time": 0,
                                "volume": 1.0,
                                "track": "voice"
                            }
                        })
                    
                    # 3. æ·»åŠ BGM (å¦‚æœå¯ç”¨)
                    if params_data.get("enable_bgm") and not bgm_data.get("error"):
                        operations.append({
                            "operation": "add_audio",
                            "params": {
                                "draft_id": draft_id,
                                "audio_path": bgm_data.get("bgm_url"),
                                "start_time": 0,
                                "volume": bgm_data.get("volume", 0.3),
                                "track": "bgm",
                                "fade_in": bgm_data.get("fade_in", 2),
                                "fade_out": bgm_data.get("fade_out", 2)
                            }
                        })
                    
                    # æ‰§è¡Œæ‰¹é‡æ“ä½œ (MCPä¼˜å…ˆï¼ŒHTTPé™çº§)
                    try:
                        # å°è¯•MCPæ‰¹é‡æ“ä½œ
                        response = requests.post(
                            f"{mcp_url}/mcp",
                            json={
                                "method": "batch_operations",
                                "params": {
                                    "draft_id": draft_id,
                                    "operations": operations
                                }
                            },
                            timeout=30
                        )
                        
                        if response.status_code == 200:
                            result = response.json()
                            assembly_result = {
                                "draft_id": draft_id,
                                "operations_count": len(operations),
                                "method": "mcp_batch",
                                "success": True
                            }
                        else:
                            raise Exception(f"MCPæ‰¹é‡æ“ä½œå¤±è´¥: {response.status_code}")
                            
                    except Exception as mcp_error:
                        # é™çº§åˆ°HTTPé€ä¸ªæ“ä½œ
                        capcut_url = os.getenv("CAPCUT_API_URL", "http://localhost:9000")
                        success_count = 0
                        
                        for op in operations:
                            try:
                                op_response = requests.post(
                                    f"{capcut_url}/{op['operation']}",
                                    json=op['params'],
                                    timeout=10
                                )
                                if op_response.status_code == 200:
                                    success_count += 1
                            except:
                                continue
                        
                        assembly_result = {
                            "draft_id": draft_id,
                            "operations_count": len(operations),
                            "success_count": success_count,
                            "method": "http_fallback",
                            "success": success_count > 0,
                            "mcp_error": str(mcp_error)
                        }
                    
                    return {
                        "assembly_result": json.dumps(assembly_result),
                        "draft_id": draft_id
                    }
                    
                except Exception as e:
                    return {
                        "assembly_result": json.dumps({"error": str(e), "success": False}),
                        "draft_id": ""
                    }
          desc: "åŸºäºéŸ³é¢‘ä¸»æ—¶é’Ÿè¿›è¡Œæ—¶é—´è½´è£…é…"
          outputs:
            assembly_result:
              type: string
            draft_id:
              type: string
          selected: false
          title: "æ—¶é—´è½´è£…é…"
          type: code
          variables:
            - value_selector:
                - create_draft
                - result
              variable: draft_result
            - value_selector:
                - parallel_materials
                - tts_branch
                - tts_result
              variable: tts_result
            - value_selector:
                - parallel_materials
                - visual_branch
                - visual_result
              variable: visual_result
            - value_selector:
                - parallel_materials
                - subtitle_branch
                - subtitle_result
              variable: subtitle_result
            - value_selector:
                - parallel_materials
                - bgm_branch
                - bgm_result
              variable: bgm_result
            - value_selector:
                - validate_input
                - validated_params
              variable: validated_params
        height: 54
        id: timeline_assembly
        position:
          x: 1600
          y: 282
        positionAbsolute:
          x: 1600
          y: 282
        selected: false
        type: code
        width: 244

      # èŠ‚ç‚¹7: éŸ³é¢‘æ··åˆå¤„ç†
      - data:
          desc: "ä½¿ç”¨MCP Bridgeè¿›è¡ŒéŸ³é¢‘æ··åˆå’ŒéŸ³é‡è°ƒèŠ‚"
          selected: false
          title: "éŸ³é¢‘æ··åˆ"
          type: tool
          provider_id: capcut-mcp-bridge
          provider_type: builtin
          tool_name: audio_mixing
          tool_parameters:
            draft_id:
              type: mixed
              value: "{{#timeline_assembly.draft_id#}}"
            voice_volume:
              type: mixed
              value: "1.0"
            bgm_volume:
              type: mixed
              value: "0.3"
            enable_ducking:
              type: mixed
              value: "true"
        height: 54
        id: audio_mixing
        position:
          x: 1904
          y: 282
        positionAbsolute:
          x: 1904
          y: 282
        selected: false
        type: tool
        width: 244

      # èŠ‚ç‚¹8: å­—å¹•å¯¹é½
      - data:
          code: |
            import json
            import requests
            import os
            
            def main(draft_id: str, subtitle_result: str, validated_params: str) -> dict:
                """
                å­—å¹•ä¸æœ€ç»ˆéŸ³é¢‘æ—¶é—´æˆ³å¯¹é½
                """
                try:
                    subtitle_data = json.loads(subtitle_result)
                    params_data = json.loads(validated_params)
                    
                    if not params_data.get("enable_subtitle", True):
                        return {
                            "subtitle_alignment_result": json.dumps({
                                "success": True,
                                "message": "å­—å¹•åŠŸèƒ½å·²ç¦ç”¨",
                                "draft_id": draft_id
                            })
                        }
                    
                    if subtitle_data.get("error"):
                        raise ValueError(f"å­—å¹•æ•°æ®é”™è¯¯: {subtitle_data['error']}")
                    
                    # MCP Bridge URL
                    mcp_url = os.getenv("MCP_BRIDGE_URL", "http://localhost:8082")
                    
                    # å‡†å¤‡å­—å¹•æ•°æ®
                    subtitles = subtitle_data.get("subtitles", [])
                    
                    try:
                        # å°è¯•MCPæ‰¹é‡æ·»åŠ å­—å¹•
                        response = requests.post(
                            f"{mcp_url}/mcp",
                            json={
                                "method": "add_subtitles_batch",
                                "params": {
                                    "draft_id": draft_id,
                                    "subtitles": subtitles,
                                    "style": {
                                        "font_size": 48,
                                        "font_color": "#FFFFFF",
                                        "background_color": "#000000",
                                        "background_opacity": 0.7
                                    }
                                }
                            },
                            timeout=30
                        )
                        
                        if response.status_code == 200:
                            result = response.json()
                            alignment_result = {
                                "success": True,
                                "method": "mcp_batch",
                                "subtitles_count": len(subtitles),
                                "draft_id": draft_id
                            }
                        else:
                            raise Exception(f"MCPå­—å¹•æ·»åŠ å¤±è´¥: {response.status_code}")
                            
                    except Exception as mcp_error:
                        # é™çº§åˆ°HTTPé€ä¸ªæ·»åŠ 
                        capcut_url = os.getenv("CAPCUT_API_URL", "http://localhost:9000")
                        success_count = 0
                        
                        for subtitle in subtitles:
                            try:
                                sub_response = requests.post(
                                    f"{capcut_url}/add_subtitle",
                                    json={
                                        "draft_id": draft_id,
                                        "text": subtitle.get("text"),
                                        "start_time": subtitle.get("start_time"),
                                        "end_time": subtitle.get("end_time"),
                                        "font_size": 48,
                                        "color": "#FFFFFF"
                                    },
                                    timeout=10
                                )
                                if sub_response.status_code == 200:
                                    success_count += 1
                            except:
                                continue
                        
                        alignment_result = {
                            "success": success_count > 0,
                            "method": "http_fallback",
                            "subtitles_count": len(subtitles),
                            "success_count": success_count,
                            "draft_id": draft_id,
                            "mcp_error": str(mcp_error)
                        }
                    
                    return {
                        "subtitle_alignment_result": json.dumps(alignment_result)
                    }
                    
                except Exception as e:
                    return {
                        "subtitle_alignment_result": json.dumps({
                            "error": str(e),
                            "success": False,
                            "draft_id": draft_id
                        })
                    }
          desc: "å­—å¹•ä¸æœ€ç»ˆéŸ³é¢‘æ—¶é—´æˆ³ç²¾ç¡®å¯¹é½"
          outputs:
            subtitle_alignment_result:
              type: string
          selected: false
          title: "å­—å¹•å¯¹é½"
          type: code
          variables:
            - value_selector:
                - timeline_assembly
                - draft_id
              variable: draft_id
            - value_selector:
                - parallel_materials
                - subtitle_branch
                - subtitle_result
              variable: subtitle_result
            - value_selector:
                - validate_input
                - validated_params
              variable: validated_params
        height: 54
        id: subtitle_alignment
        position:
          x: 2208
          y: 282
        positionAbsolute:
          x: 2208
          y: 282
        selected: false
        type: code
        width: 244

      # èŠ‚ç‚¹9: æ¸²æŸ“æäº¤
      - data:
          code: |
            import json
            import requests
            import os
            import time
            
            def main(draft_id: str, validated_params: str) -> dict:
                """
                æäº¤æ¸²æŸ“ä»»åŠ¡ - MCPä¼˜å…ˆï¼ŒHTTPé™çº§
                """
                try:
                    params_data = json.loads(validated_params)
                    
                    if not draft_id:
                        raise ValueError("è‰ç¨¿IDä¸å­˜åœ¨")
                    
                    # æ¸²æŸ“å‚æ•°
                    render_params = {
                        "draft_id": draft_id,
                        "output_format": "mp4",
                        "quality": "high",
                        "resolution": f"{params_data.get('video_width', 1080)}x{params_data.get('video_height', 1920)}",
                        "frame_rate": 30,
                        "bitrate": "auto"
                    }
                    
                    # MCP Bridge URL
                    mcp_url = os.getenv("MCP_BRIDGE_URL", "http://localhost:8082")
                    
                    try:
                        # å°è¯•MCPæ¸²æŸ“æäº¤
                        response = requests.post(
                            f"{mcp_url}/mcp",
                            json={
                                "method": "submit_render",
                                "params": render_params
                            },
                            timeout=30
                        )
                        
                        if response.status_code == 200:
                            result = response.json()
                            render_result = {
                                "success": True,
                                "method": "mcp",
                                "task_id": result.get("task_id"),
                                "draft_id": draft_id,
                                "estimated_time": result.get("estimated_time", 120),
                                "status": "submitted"
                            }
                        else:
                            raise Exception(f"MCPæ¸²æŸ“æäº¤å¤±è´¥: {response.status_code}")
                            
                    except Exception as mcp_error:
                        # é™çº§åˆ°HTTPæ¸²æŸ“
                        capcut_url = os.getenv("CAPCUT_API_URL", "http://localhost:9000")
                        
                        try:
                            render_response = requests.post(
                                f"{capcut_url}/export_video",
                                json=render_params,
                                timeout=30
                            )
                            
                            if render_response.status_code == 200:
                                result = render_response.json()
                                render_result = {
                                    "success": True,
                                    "method": "http_fallback",
                                    "task_id": result.get("task_id"),
                                    "draft_id": draft_id,
                                    "estimated_time": result.get("estimated_time", 180),
                                    "status": "submitted",
                                    "mcp_error": str(mcp_error)
                                }
                            else:
                                # æœ€åé™çº§ï¼šä»…ä¿å­˜è‰ç¨¿
                                save_response = requests.post(
                                    f"{mcp_url}/mcp",
                                    json={
                                        "method": "save_draft",
                                        "params": {
                                            "draft_id": draft_id,
                                            "export_path": f"/tmp/draft_{draft_id}_{int(time.time())}.json"
                                        }
                                    },
                                    timeout=10
                                )
                                
                                render_result = {
                                    "success": False,
                                    "method": "save_draft_only",
                                    "draft_id": draft_id,
                                    "message": "æ¸²æŸ“å¤±è´¥ï¼Œå·²ä¿å­˜è‰ç¨¿",
                                    "draft_saved": save_response.status_code == 200,
                                    "errors": {
                                        "mcp_error": str(mcp_error),
                                        "http_error": f"HTTPæ¸²æŸ“å¤±è´¥: {render_response.status_code}"
                                    }
                                }
                        except Exception as http_error:
                            render_result = {
                                "success": False,
                                "method": "all_failed",
                                "draft_id": draft_id,
                                "errors": {
                                    "mcp_error": str(mcp_error),
                                    "http_error": str(http_error)
                                }
                            }
                    
                    return {
                        "render_result": json.dumps(render_result),
                        "task_id": render_result.get("task_id", ""),
                        "render_status": "submitted" if render_result.get("success") else "failed"
                    }
                    
                except Exception as e:
                    return {
                        "render_result": json.dumps({
                            "error": str(e),
                            "success": False,
                            "draft_id": draft_id
                        }),
                        "task_id": "",
                        "render_status": "error"
                    }
          desc: "æäº¤æ¸²æŸ“ä»»åŠ¡ï¼Œæ”¯æŒMCPå’ŒHTTPé™çº§"
          outputs:
            render_result:
              type: string
            task_id:
              type: string
            render_status:
              type: string
          selected: false
          title: "æ¸²æŸ“æäº¤"
          type: code
          variables:
            - value_selector:
                - timeline_assembly
                - draft_id
              variable: draft_id
            - value_selector:
                - validate_input
                - validated_params
              variable: validated_params
        height: 54
        id: submit_render
        position:
          x: 2512
          y: 282
        positionAbsolute:
          x: 2512
          y: 282
        selected: false
        type: code
        width: 244

      # èŠ‚ç‚¹10: è¿›åº¦ç›‘æ§
      - data:
          code: |
            import json
            import requests
            import os
            import time
            
            def main(task_id: str, render_status: str, render_result: str) -> dict:
                """
                ç›‘æ§æ¸²æŸ“è¿›åº¦ - å›è°ƒä¼˜å…ˆï¼Œè½®è¯¢é™çº§
                """
                try:
                    if render_status != "submitted" or not task_id:
                        # æ¸²æŸ“æœªæˆåŠŸæäº¤ï¼Œç›´æ¥è¿”å›å¤±è´¥ç»“æœ
                        return {
                            "final_result": render_result,
                            "video_url": "",
                            "status": "failed"
                        }
                    
                    render_data = json.loads(render_result)
                    estimated_time = render_data.get("estimated_time", 120)
                    method = render_data.get("method", "unknown")
                    
                    # è®¾ç½®è¶…æ—¶æ—¶é—´
                    timeout = int(os.getenv("RENDER_TIMEOUT", "300"))
                    start_time = time.time()
                    
                    # MCP Bridge URL
                    mcp_url = os.getenv("MCP_BRIDGE_URL", "http://localhost:8082")
                    capcut_url = os.getenv("CAPCUT_API_URL", "http://localhost:9000")
                    
                    # é€‰æ‹©æŸ¥è¯¢URL
                    if method == "mcp":
                        query_url = f"{mcp_url}/mcp"
                        query_payload = {
                            "method": "get_render_status",
                            "params": {"task_id": task_id}
                        }
                    else:
                        query_url = f"{capcut_url}/get_render_status"
                        query_payload = {"task_id": task_id}
                    
                    # è½®è¯¢æŸ¥è¯¢è¿›åº¦
                    while time.time() - start_time < timeout:
                        try:
                            if method == "mcp":
                                response = requests.post(query_url, json=query_payload, timeout=10)
                            else:
                                response = requests.get(f"{query_url}?task_id={task_id}", timeout=10)
                            
                            if response.status_code == 200:
                                result = response.json()
                                status = result.get("status", "unknown")
                                progress = result.get("progress", 0)
                                
                                if status == "completed":
                                    # æ¸²æŸ“å®Œæˆ
                                    final_result = {
                                        "success": True,
                                        "status": "completed",
                                        "video_url": result.get("video_url", ""),
                                        "thumbnail_url": result.get("thumbnail_url", ""),
                                        "duration": result.get("duration", 0),
                                        "file_size": result.get("file_size", 0),
                                        "task_id": task_id,
                                        "render_time": int(time.time() - start_time),
                                        "method": method
                                    }
                                    
                                    return {
                                        "final_result": json.dumps(final_result),
                                        "video_url": result.get("video_url", ""),
                                        "status": "completed"
                                    }
                                
                                elif status == "failed":
                                    # æ¸²æŸ“å¤±è´¥
                                    final_result = {
                                        "success": False,
                                        "status": "failed",
                                        "error": result.get("error", "æ¸²æŸ“å¤±è´¥"),
                                        "task_id": task_id,
                                        "method": method
                                    }
                                    
                                    return {
                                        "final_result": json.dumps(final_result),
                                        "video_url": "",
                                        "status": "failed"
                                    }
                                
                                elif status in ["processing", "queued"]:
                                    # ç»§ç»­ç­‰å¾…
                                    print(f"æ¸²æŸ“è¿›åº¦: {progress}%, çŠ¶æ€: {status}")
                                    time.sleep(5)  # ç­‰å¾…5ç§’åå†æ¬¡æŸ¥è¯¢
                                    continue
                            
                            else:
                                print(f"æŸ¥è¯¢çŠ¶æ€å¤±è´¥: {response.status_code}")
                                time.sleep(10)  # æŸ¥è¯¢å¤±è´¥ï¼Œç­‰å¾…æ›´é•¿æ—¶é—´
                                
                        except Exception as query_error:
                            print(f"æŸ¥è¯¢å¼‚å¸¸: {query_error}")
                            time.sleep(10)
                    
                    # è¶…æ—¶å¤„ç†
                    timeout_result = {
                        "success": False,
                        "status": "timeout",
                        "error": f"æ¸²æŸ“è¶…æ—¶ (>{timeout}ç§’)",
                        "task_id": task_id,
                        "method": method,
                        "elapsed_time": int(time.time() - start_time)
                    }
                    
                    return {
                        "final_result": json.dumps(timeout_result),
                        "video_url": "",
                        "status": "timeout"
                    }
                    
                except Exception as e:
                    error_result = {
                        "success": False,
                        "status": "error",
                        "error": str(e),
                        "task_id": task_id
                    }
                    
                    return {
                        "final_result": json.dumps(error_result),
                        "video_url": "",
                        "status": "error"
                    }
          desc: "ç›‘æ§æ¸²æŸ“è¿›åº¦ï¼Œæ”¯æŒå›è°ƒå’Œè½®è¯¢"
          outputs:
            final_result:
              type: string
            video_url:
              type: string
            status:
              type: string
          selected: false
          title: "è¿›åº¦ç›‘æ§"
          type: code
          variables:
            - value_selector:
                - submit_render
                - task_id
              variable: task_id
            - value_selector:
                - submit_render
                - render_status
              variable: render_status
            - value_selector:
                - submit_render
                - render_result
              variable: render_result
        height: 54
        id: monitor_progress
        position:
          x: 2816
          y: 282
        positionAbsolute:
          x: 2816
          y: 282
        selected: false
        type: code
        width: 244

      # èŠ‚ç‚¹11: ç»“æœè¾“å‡º
      - data:
          desc: "è¾“å‡ºæœ€ç»ˆçš„è§†é¢‘ç”Ÿæˆç»“æœ"
          outputs:
            - value_selector:
                - monitor_progress
                - video_url
              variable: video_url
            - value_selector:
                - monitor_progress
                - status
              variable: generation_status
            - value_selector:
                - monitor_progress
                - final_result
              variable: final_result
            - value_selector:
                - timeline_assembly
                - draft_id
              variable: draft_id
            - value_selector:
                - generate_script
                - text
              variable: video_script
          selected: false
          title: "ç»“æœè¾“å‡º"
          type: end
        height: 90
        id: end
        position:
          x: 3120
          y: 282
        positionAbsolute:
          x: 3120
          y: 282
        selected: false
        type: end
        width: 244

  features:
    file_upload:
      image:
        enabled: true
        number_limits: 10
        transfer_methods:
          - local_file
          - remote_url
    opening_statement: |
      ğŸ¬ æ¬¢è¿ä½¿ç”¨æ™ºèƒ½çŸ­è§†é¢‘ç”Ÿæˆå™¨ v2.0ï¼

      è¿™æ˜¯ä¸€ä¸ªåŸºäº MCP Bridge çš„ä¼˜åŒ–ç‰ˆçŸ­è§†é¢‘å·¥ä½œæµï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š
      
      âœ¨ **ç®€åŒ–æ“ä½œ**ï¼šä»40+èŠ‚ç‚¹ä¼˜åŒ–åˆ°11ä¸ªæ ¸å¿ƒèŠ‚ç‚¹
      âš¡ **é«˜æ•ˆç”Ÿæˆ**ï¼š3-5åˆ†é’Ÿå®ŒæˆçŸ­è§†é¢‘åˆ¶ä½œ
      ğŸ›¡ï¸ **ç¨³å®šå¯é **ï¼šMCPä¼˜å…ˆï¼ŒHTTPé™çº§ï¼ŒæˆåŠŸç‡â‰¥95%
      ğŸ¯ **æ™ºèƒ½é»˜è®¤**ï¼šå‡å°‘ç”¨æˆ·é…ç½®ï¼Œ5æ­¥å†…å®Œæˆæ“ä½œ

      **ä½¿ç”¨æ­¥éª¤ï¼š**
      1. è¾“å…¥è§†é¢‘ä¸»é¢˜ï¼ˆå¿…å¡«ï¼‰
      2. é€‰æ‹©è§†é¢‘å‚æ•°ï¼ˆå¯é€‰ï¼Œæœ‰æ™ºèƒ½é»˜è®¤å€¼ï¼‰
      3. ç‚¹å‡»å¼€å§‹ç”Ÿæˆ
      4. ç­‰å¾…3-5åˆ†é’Ÿ
      5. è·å–æˆå“è§†é¢‘

      è¯·è¾“å…¥æ‚¨çš„è§†é¢‘ä¸»é¢˜å¼€å§‹åˆ›ä½œå§ï¼
    
    retriever_resource:
      enabled: false
    
    sensitive_word_avoidance:
      enabled: false
    
    speech_to_text:
      enabled: false
    
    suggested_questions:
      - "åˆ¶ä½œä¸€ä¸ª30ç§’çš„äº§å“ä»‹ç»è§†é¢‘"
      - "ç”Ÿæˆæ•™è‚²ç§‘æ™®ç±»çŸ­è§†é¢‘"
      - "åˆ›å»ºè¥é”€æ¨å¹¿çŸ­ç‰‡"
      - "åˆ¶ä½œä¸ªäººvlogé£æ ¼è§†é¢‘"
    
    suggested_questions_after_answer:
      enabled: false
    
    text_to_speech:
      enabled: false
      language: ""
      voice: ""