# CapCut API MCP 服务实施指南

## 概述

本指南详细说明如何将 CapCut API MCP 服务集成到 Dify 工作流中，包括完整的部署、配置和使用流程。

## 🚀 快速开始（5分钟体验）

### 方案选择

根据你的需求选择合适的方案：

| 需求场景 | 推荐方案 | 部署时间 | 复杂度 |
|---------|---------|---------|--------|
| **个人学习/测试** | 官方简单方案 | 5分钟 | ⭐ |
| **小型项目** | 官方简单方案 | 5分钟 | ⭐ |
| **生产环境** | 企业级Bridge方案 | 30分钟 | ⭐⭐⭐⭐ |
| **高并发需求** | 企业级Bridge方案 | 30分钟 | ⭐⭐⭐⭐ |

### 📋 方案一：官方简单方案（推荐新手）

#### 系统要求
- Python 3.9+
- 内存: 512MB+
- 磁盘: 1GB+

#### 快速部署
```bash
# 1. 启动CapCut API服务
./service_manager.sh start

# 2. 部署简单MCP服务器
chmod +x start_simple_mcp.sh
./start_simple_mcp.sh

# 3. 在Dify中配置MCP
# 服务器URL: stdio://simple_mcp_server.py
```

### 📋 方案二：企业级Bridge方案（推荐生产环境）

#### 系统要求
- Python 3.11+
- 内存: 2GB+
- 磁盘: 5GB+
- Redis服务

#### 一键部署
```bash
# 一键部署企业级方案
./setup_dify_integration.sh deploy

# 启动所有服务
./setup_dify_integration.sh start

# 验证部署
./setup_dify_integration.sh test
```

## 目录

1. [系统架构](#系统架构)
2. [环境准备](#环境准备)
3. [详细部署](#详细部署)
4. [详细配置](#详细配置)
5. [Dify 集成](#dify-集成)
6. [工作流设计](#工作流设计)
7. [API 使用示例](#api-使用示例)
8. [故障排除](#故障排除)
9. [性能优化](#性能优化)
10. [安全配置](#安全配置)

## 系统架构

### 整体架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│                 │    │                 │    │                 │
│   Dify 工作流    │◄──►│   MCP Bridge    │◄──►│   CapCut API    │
│                 │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│                 │    │                 │    │                 │
│  Dify 数据库     │    │  Redis 缓存      │    │  CapCut 引擎     │
│                 │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 组件说明

1. **Dify 工作流**: 用户界面和工作流编排
2. **MCP Bridge**: MCP 协议桥接服务
3. **CapCut API**: 视频编辑核心服务
4. **Redis 缓存**: 会话和数据缓存
5. **数据库**: 持久化存储

## 环境准备

### 系统要求

- **操作系统**: Linux (Ubuntu 18.04+, CentOS 7+)
- **Python**: 3.8 或更高版本
- **内存**: 最少 4GB，推荐 8GB
- **存储**: 最少 10GB 可用空间
- **网络**: 稳定的网络连接

### 必需软件

```bash
# 更新系统包
sudo apt update && sudo apt upgrade -y

# 安装 Python 和相关工具
sudo apt install python3 python3-pip python3-venv -y

# 安装系统依赖
sudo apt install curl jq redis-server ffmpeg -y

# 安装 Docker (可选，用于容器化部署)
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker $USER
```

### 端口规划

| 服务 | 端口 | 协议 | 说明 |
|------|------|------|------|
| CapCut API | 9000 | HTTP | 主要 API 服务 |
| MCP Server | 8080 | WebSocket | MCP 协议服务 |
| Bridge Server | 8081 | HTTP | 桥接服务 |
| Redis | 6379 | TCP | 缓存服务 |
| Dify | 5001 | HTTP | Dify API 服务 |
| Prometheus | 9090 | HTTP | 监控指标 |

## 详细部署

### 一键部署脚本

```bash
# 进入项目目录
cd /home/CapCutAPI-1.1.0

# 赋予执行权限
chmod +x setup_dify_integration.sh

# 执行部署 (基础部署)
./setup_dify_integration.sh

# 执行部署 (包含 Dify 集成)
./setup_dify_integration.sh \
  --dify-api "http://localhost:5001" \
  --dify-key "your-dify-api-key" \
  --mcp-port 8080 \
  --bridge-port 8081
```

### 验证部署

```bash
# 检查服务状态
./manage_integration.sh status

# 测试 API 连接
curl http://localhost:9000/get_intro_animation_types
curl http://localhost:8081/health
curl ws://localhost:8080 # WebSocket 连接测试

# 运行集成测试
./manage_integration.sh test
```

## 详细配置

### MCP Bridge 配置

#### 主配置文件 (`config/production.yaml`)

```yaml
# 服务器配置
server:
  host: "0.0.0.0"
  port: 8081
  workers: 4
  debug: false
  
# MCP 服务器配置
mcp_server:
  host: "0.0.0.0"
  port: 8080
  max_connections: 100
  timeout: 30
  heartbeat_interval: 30
  
# CapCut API 配置
capcut_api:
  base_url: "http://localhost:9000"
  timeout: 60
  max_retries: 3
  retry_delay: 1
  
# Redis 配置
redis:
  host: "localhost"
  port: 6379
  db: 0
  password: ""
  max_connections: 20
  
# 日志配置
logging:
  level: "INFO"
  file: "logs/bridge.log"
  max_size: "100MB"
  backup_count: 5
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  
# 监控配置
monitoring:
  enabled: true
  metrics_port: 9090
  health_check_interval: 30
  
# 安全配置
security:
  api_key_required: false
  api_key: ""
  cors_enabled: true
  cors_origins: ["*"]
  rate_limit:
    enabled: true
    requests_per_minute: 100
    burst_size: 20
```

#### 开发环境配置 (`config/development.yaml`)

```yaml
# 继承生产配置并覆盖特定设置
server:
  debug: true
  
logging:
  level: "DEBUG"
  
security:
  cors_origins: ["http://localhost:3000", "http://localhost:5001"]
```

### Dify 集成配置

#### 集成配置文件 (`config/dify_integration.yaml`)

```yaml
# Dify 连接配置
dify:
  api_base_url: "http://localhost:5001"
  api_key: ""  # 从环境变量获取
  timeout: 30
  max_retries: 3
  
# MCP 服务器信息
mcp_server:
  name: "CapCut API MCP Server"
  description: "CapCut 视频编辑 API 的 MCP 服务器"
  url: "ws://localhost:8080"
  version: "1.0.0"
  capabilities:
    tools: true
    resources: true
    prompts: false
  
# 工作流配置
workflows:
  templates_dir: "templates"
  auto_deploy: false
  backup_enabled: true
  
# 集成设置
integration:
  auto_register: true
  health_check_interval: 60
  retry_count: 3
  sync_interval: 300
```

## Dify 集成

### 手动注册 MCP 服务器

1. **登录 Dify 管理界面**
   ```
   http://localhost:5001/admin
   ```

2. **导航到 MCP 服务器设置**
   - 点击左侧菜单 "设置"
   - 选择 "模型供应商"
   - 点击 "MCP 服务器" 标签

3. **添加新的 MCP 服务器**
   - 点击 "添加 MCP 服务器" 按钮
   - 填写服务器信息：
     ```
     名称: CapCut API MCP Server
     URL: ws://localhost:8080
     描述: CapCut 视频编辑 API 的 MCP 服务器
     ```

4. **测试连接**
   - 点击 "测试连接" 按钮
   - 确认连接状态为 "已连接"
   - 查看可用工具列表

5. **保存配置**
   - 点击 "保存" 按钮
   - 确认服务器已添加到列表中

### 自动注册脚本

```python
# 使用 Python 脚本自动注册
import requests
import json

def register_mcp_server():
    dify_api_url = "http://localhost:5001"
    api_key = "your-dify-api-key"
    
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    
    server_config = {
        "name": "CapCut API MCP Server",
        "url": "ws://localhost:8080",
        "description": "CapCut 视频编辑 API 的 MCP 服务器",
        "capabilities": {
            "tools": True,
            "resources": True
        }
    }
    
    response = requests.post(
        f"{dify_api_url}/api/v1/mcp-servers",
        headers=headers,
        json=server_config
    )
    
    if response.status_code == 201:
        print("MCP 服务器注册成功")
        return response.json()
    else:
        print(f"注册失败: {response.text}")
        return None

# 执行注册
if __name__ == "__main__":
    register_mcp_server()
```

## 工作流设计

### 基础视频生成工作流

#### 工作流结构

```yaml
name: "CapCut 视频生成工作流"
description: "使用 CapCut API 自动生成视频"
version: "1.0.0"

nodes:
  - id: "start"
    type: "start"
    name: "开始"
    
  - id: "create_draft"
    type: "tool"
    name: "创建草稿"
    tool: "create_draft"
    inputs:
      title: "{{ inputs.video_title }}"
      description: "{{ inputs.video_description }}"
    
  - id: "add_video"
    type: "tool"
    name: "添加视频"
    tool: "add_video"
    inputs:
      draft_id: "{{ create_draft.draft_id }}"
      video_url: "{{ inputs.video_url }}"
      start_time: 0
      duration: "{{ inputs.video_duration }}"
    
  - id: "add_text"
    type: "tool"
    name: "添加标题"
    tool: "add_text"
    inputs:
      draft_id: "{{ create_draft.draft_id }}"
      text: "{{ inputs.title_text }}"
      font_size: 48
      position: "center"
    
  - id: "add_effect"
    type: "tool"
    name: "添加特效"
    tool: "add_effect"
    inputs:
      draft_id: "{{ create_draft.draft_id }}"
      effect_type: "{{ inputs.effect_type }}"
      intensity: 0.8
    
  - id: "save_draft"
    type: "tool"
    name: "保存草稿"
    tool: "save_draft"
    inputs:
      draft_id: "{{ create_draft.draft_id }}"
    
  - id: "end"
    type: "end"
    name: "结束"
    outputs:
      draft_id: "{{ create_draft.draft_id }}"
      video_url: "{{ save_draft.video_url }}"

connections:
  - from: "start"
    to: "create_draft"
  - from: "create_draft"
    to: "add_video"
  - from: "add_video"
    to: "add_text"
  - from: "add_text"
    to: "add_effect"
  - from: "add_effect"
    to: "save_draft"
  - from: "save_draft"
    to: "end"
```

#### 输入参数

```json
{
  "video_title": "我的视频标题",
  "video_description": "视频描述信息",
  "video_url": "https://example.com/video.mp4",
  "video_duration": 30,
  "title_text": "欢迎观看",
  "effect_type": "fade_in"
}
```

### 高级批量处理工作流

#### 工作流特性

- 支持批量视频处理
- 自动错误重试
- 进度跟踪
- 结果汇总

#### 节点配置示例

```yaml
# 批量处理节点
- id: "batch_process"
  type: "loop"
  name: "批量处理视频"
  loop_variable: "video_item"
  loop_data: "{{ inputs.video_list }}"
  nodes:
    - id: "process_single_video"
      type: "subflow"
      name: "处理单个视频"
      subflow: "single_video_workflow"
      inputs:
        video_url: "{{ video_item.url }}"
        title: "{{ video_item.title }}"
      error_handling:
        retry_count: 3
        retry_delay: 5
        on_error: "continue"
```

## API 使用示例

### 创建视频草稿

```python
import asyncio
import websockets
import json

async def create_video_draft():
    uri = "ws://localhost:8080"
    
    async with websockets.connect(uri) as websocket:
        # 发送创建草稿请求
        request = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "tools/call",
            "params": {
                "name": "create_draft",
                "arguments": {
                    "title": "我的第一个视频",
                    "description": "使用 CapCut API 创建的视频"
                }
            }
        }
        
        await websocket.send(json.dumps(request))
        response = await websocket.recv()
        result = json.loads(response)
        
        print(f"草稿创建成功: {result}")
        return result["result"]["draft_id"]

# 运行示例
draft_id = asyncio.run(create_video_draft())
```

### 添加视频内容

```python
async def add_video_content(draft_id, video_url):
    uri = "ws://localhost:8080"
    
    async with websockets.connect(uri) as websocket:
        request = {
            "jsonrpc": "2.0",
            "id": 2,
            "method": "tools/call",
            "params": {
                "name": "add_video",
                "arguments": {
                    "draft_id": draft_id,
                    "video_url": video_url,
                    "start_time": 0,
                    "duration": 30,
                    "position": {
                        "x": 0,
                        "y": 0,
                        "width": 1920,
                        "height": 1080
                    }
                }
            }
        }
        
        await websocket.send(json.dumps(request))
        response = await websocket.recv()
        result = json.loads(response)
        
        print(f"视频添加成功: {result}")
        return result

# 使用示例
video_url = "https://example.com/sample.mp4"
result = asyncio.run(add_video_content(draft_id, video_url))
```

### 批量操作示例

```python
async def batch_create_videos(video_configs):
    """批量创建视频"""
    results = []
    
    for config in video_configs:
        try:
            # 创建草稿
            draft_id = await create_video_draft()
            
            # 添加视频
            await add_video_content(draft_id, config["video_url"])
            
            # 添加文本
            await add_text_overlay(draft_id, config["title"])
            
            # 保存草稿
            video_url = await save_draft(draft_id)
            
            results.append({
                "draft_id": draft_id,
                "video_url": video_url,
                "status": "success"
            })
            
        except Exception as e:
            results.append({
                "config": config,
                "error": str(e),
                "status": "failed"
            })
    
    return results

# 批量处理配置
video_configs = [
    {
        "video_url": "https://example.com/video1.mp4",
        "title": "视频1标题"
    },
    {
        "video_url": "https://example.com/video2.mp4",
        "title": "视频2标题"
    }
]

# 执行批量处理
results = asyncio.run(batch_create_videos(video_configs))
```

## 故障排除

### 常见问题及解决方案

#### 1. MCP 服务器连接失败

**症状**: Dify 无法连接到 MCP 服务器

**可能原因**:
- MCP 服务器未启动
- 端口被占用
- 防火墙阻止连接
- 网络配置问题

**解决步骤**:
```bash
# 检查服务状态
./manage_integration.sh status

# 检查端口占用
netstat -tlnp | grep 8080

# 查看服务日志
./manage_integration.sh logs mcp

# 重启服务
./manage_integration.sh restart

# 测试连接
curl -v ws://localhost:8080
```

#### 2. API 调用超时

**症状**: 工具调用时出现超时错误

**可能原因**:
- CapCut API 服务响应慢
- 网络延迟
- 资源不足

**解决步骤**:
```bash
# 检查 CapCut API 状态
curl http://localhost:9000/get_intro_animation_types

# 查看系统资源
top
df -h

# 调整超时配置
# 编辑 config/production.yaml
# 增加 timeout 值
```

#### 3. 工作流执行失败

**症状**: Dify 工作流执行时报错

**可能原因**:
- 参数配置错误
- 工具调用失败
- 数据格式不匹配

**解决步骤**:
```bash
# 查看详细日志
./manage_integration.sh logs bridge

# 测试单个工具
./manage_integration.sh test

# 验证参数格式
# 检查工作流配置
```

### 日志分析

#### 日志级别说明

- **DEBUG**: 详细的调试信息
- **INFO**: 一般信息
- **WARNING**: 警告信息
- **ERROR**: 错误信息
- **CRITICAL**: 严重错误

#### 常见错误模式

```bash
# 连接错误
grep "Connection" logs/mcp_server.log

# 超时错误
grep "timeout" logs/bridge.log

# API 错误
grep "API Error" logs/bridge.log

# 认证错误
grep "Authentication" logs/bridge.log
```

### 性能调优

#### 系统资源监控

```bash
# CPU 使用率
top -p $(pgrep -f "mcp_server|bridge_server")

# 内存使用
ps aux | grep -E "mcp_server|bridge_server"

# 网络连接
netstat -an | grep -E "8080|8081"

# 磁盘 I/O
iotop
```

#### 配置优化

```yaml
# 增加工作进程数
server:
  workers: 8  # 根据 CPU 核心数调整

# 优化连接池
mcp_server:
  max_connections: 200
  
redis:
  max_connections: 50

# 调整超时设置
capcut_api:
  timeout: 120
  max_retries: 5
```

## 性能优化

### 缓存策略

#### Redis 缓存配置

```yaml
# 缓存配置
cache:
  enabled: true
  default_ttl: 3600  # 1小时
  max_memory: "256mb"
  
  # 缓存策略
  policies:
    draft_info: 1800    # 30分钟
    video_metadata: 3600 # 1小时
    user_sessions: 7200  # 2小时
```

#### 应用层缓存

```python
from functools import lru_cache
import redis

# 内存缓存
@lru_cache(maxsize=1000)
def get_animation_types():
    """缓存动画类型数据"""
    return fetch_animation_types_from_api()

# Redis 缓存
redis_client = redis.Redis(host='localhost', port=6379, db=0)

def cached_api_call(key, func, ttl=3600):
    """通用 Redis 缓存装饰器"""
    cached_result = redis_client.get(key)
    if cached_result:
        return json.loads(cached_result)
    
    result = func()
    redis_client.setex(key, ttl, json.dumps(result))
    return result
```

### 连接池优化

```python
import asyncio
import aiohttp
from aiohttp_session import setup
from aiohttp_session.redis_storage import RedisStorage

class ConnectionManager:
    def __init__(self):
        self.http_session = None
        self.redis_pool = None
        
    async def initialize(self):
        # HTTP 连接池
        connector = aiohttp.TCPConnector(
            limit=100,
            limit_per_host=20,
            ttl_dns_cache=300,
            use_dns_cache=True
        )
        
        self.http_session = aiohttp.ClientSession(
            connector=connector,
            timeout=aiohttp.ClientTimeout(total=30)
        )
        
        # Redis 连接池
        self.redis_pool = aioredis.ConnectionPool.from_url(
            "redis://localhost:6379",
            max_connections=20
        )
```

### 异步处理优化

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AsyncTaskManager:
    def __init__(self, max_workers=10):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.semaphore = asyncio.Semaphore(max_workers)
        
    async def execute_task(self, func, *args, **kwargs):
        """异步执行任务"""
        async with self.semaphore:
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(
                self.executor, func, *args, **kwargs
            )
    
    async def batch_execute(self, tasks):
        """批量执行任务"""
        return await asyncio.gather(*tasks, return_exceptions=True)
```

## 安全配置

### API 密钥管理

#### 环境变量配置

```bash
# .env 文件
DIFY_API_KEY=your-secret-api-key
MCP_BRIDGE_API_KEY=your-bridge-api-key
REDIS_PASSWORD=your-redis-password
JWT_SECRET_KEY=your-jwt-secret

# 加载环境变量
export $(cat .env | xargs)
```

#### 密钥轮换策略

```python
import os
import hashlib
from datetime import datetime, timedelta

class APIKeyManager:
    def __init__(self):
        self.current_key = os.getenv('MCP_BRIDGE_API_KEY')
        self.key_rotation_interval = timedelta(days=30)
        
    def generate_new_key(self):
        """生成新的 API 密钥"""
        timestamp = datetime.now().isoformat()
        random_data = os.urandom(32)
        
        key_data = f"{timestamp}{random_data.hex()}"
        return hashlib.sha256(key_data.encode()).hexdigest()
    
    def rotate_key(self):
        """轮换 API 密钥"""
        new_key = self.generate_new_key()
        
        # 更新配置
        self.update_key_in_config(new_key)
        
        # 通知相关服务
        self.notify_key_rotation(new_key)
        
        return new_key
```

### 访问控制

#### IP 白名单

```yaml
# 安全配置
security:
  ip_whitelist:
    enabled: true
    allowed_ips:
      - "127.0.0.1"
      - "10.0.0.0/8"
      - "172.16.0.0/12"
      - "192.168.0.0/16"
  
  rate_limiting:
    enabled: true
    requests_per_minute: 100
    burst_size: 20
    
  cors:
    enabled: true
    allowed_origins:
      - "http://localhost:3000"
      - "http://localhost:5001"
    allowed_methods: ["GET", "POST", "PUT", "DELETE"]
    allowed_headers: ["Content-Type", "Authorization"]
```

#### JWT 认证

```python
import jwt
from datetime import datetime, timedelta

class JWTManager:
    def __init__(self, secret_key):
        self.secret_key = secret_key
        self.algorithm = "HS256"
        
    def generate_token(self, user_id, expires_in=3600):
        """生成 JWT 令牌"""
        payload = {
            "user_id": user_id,
            "exp": datetime.utcnow() + timedelta(seconds=expires_in),
            "iat": datetime.utcnow()
        }
        
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token):
        """验证 JWT 令牌"""
        try:
            payload = jwt.decode(
                token, self.secret_key, algorithms=[self.algorithm]
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise Exception("令牌已过期")
        except jwt.InvalidTokenError:
            raise Exception("无效令牌")
```

### HTTPS 配置

#### SSL 证书配置

```yaml
# HTTPS 配置
ssl:
  enabled: true
  cert_file: "/path/to/certificate.crt"
  key_file: "/path/to/private.key"
  ca_file: "/path/to/ca-bundle.crt"
  
  # SSL 选项
  ssl_version: "TLSv1.2"
  ciphers: "ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS"
```

#### 反向代理配置 (Nginx)

```nginx
server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    
    # MCP Bridge 代理
    location /mcp/ {
        proxy_pass http://localhost:8081/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # WebSocket 代理
    location /ws/ {
        proxy_pass http://localhost:8080/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

## 监控和维护

### 健康检查

```python
import asyncio
import aiohttp
from datetime import datetime

class HealthChecker:
    def __init__(self):
        self.services = {
            "capcut_api": "http://localhost:9000/health",
            "mcp_server": "ws://localhost:8080",
            "bridge_server": "http://localhost:8081/health",
            "redis": "redis://localhost:6379"
        }
    
    async def check_service_health(self, name, url):
        """检查单个服务健康状态"""
        try:
            if url.startswith("http"):
                async with aiohttp.ClientSession() as session:
                    async with session.get(url, timeout=5) as response:
                        return {
                            "service": name,
                            "status": "healthy" if response.status == 200 else "unhealthy",
                            "response_time": response.headers.get("X-Response-Time"),
                            "timestamp": datetime.now().isoformat()
                        }
            elif url.startswith("ws"):
                # WebSocket 健康检查
                return await self.check_websocket_health(name, url)
            elif url.startswith("redis"):
                # Redis 健康检查
                return await self.check_redis_health(name, url)
                
        except Exception as e:
            return {
                "service": name,
                "status": "unhealthy",
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }
    
    async def check_all_services(self):
        """检查所有服务健康状态"""
        tasks = [
            self.check_service_health(name, url)
            for name, url in self.services.items()
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results
```

### 日志聚合

```python
import logging
import json
from logging.handlers import RotatingFileHandler
from datetime import datetime

class StructuredLogger:
    def __init__(self, name, log_file, max_size=100*1024*1024):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.INFO)
        
        # 创建轮转文件处理器
        handler = RotatingFileHandler(
            log_file, maxBytes=max_size, backupCount=5
        )
        
        # 设置格式化器
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        
        self.logger.addHandler(handler)
    
    def log_structured(self, level, message, **kwargs):
        """记录结构化日志"""
        log_data = {
            "timestamp": datetime.now().isoformat(),
            "message": message,
            "level": level,
            **kwargs
        }
        
        getattr(self.logger, level.lower())(json.dumps(log_data))
    
    def log_api_call(self, method, endpoint, status_code, response_time):
        """记录 API 调用日志"""
        self.log_structured(
            "INFO",
            "API call completed",
            method=method,
            endpoint=endpoint,
            status_code=status_code,
            response_time=response_time
        )
```

### 性能指标收集

```python
import time
import psutil
from prometheus_client import Counter, Histogram, Gauge, start_http_server

# Prometheus 指标
api_requests_total = Counter(
    'api_requests_total',
    'Total API requests',
    ['method', 'endpoint', 'status']
)

api_request_duration = Histogram(
    'api_request_duration_seconds',
    'API request duration',
    ['method', 'endpoint']
)

active_connections = Gauge(
    'active_connections',
    'Number of active connections'
)

system_memory_usage = Gauge(
    'system_memory_usage_bytes',
    'System memory usage'
)

class MetricsCollector:
    def __init__(self):
        self.start_time = time.time()
        
    def record_api_request(self, method, endpoint, status_code, duration):
        """记录 API 请求指标"""
        api_requests_total.labels(
            method=method,
            endpoint=endpoint,
            status=status_code
        ).inc()
        
        api_request_duration.labels(
            method=method,
            endpoint=endpoint
        ).observe(duration)
    
    def update_system_metrics(self):
        """更新系统指标"""
        memory = psutil.virtual_memory()
        system_memory_usage.set(memory.used)
        
        # 更新其他系统指标
        cpu_usage = psutil.cpu_percent()
        disk_usage = psutil.disk_usage('/').percent
        
    def start_metrics_server(self, port=9090):
        """启动指标服务器"""
        start_http_server(port)
        print(f"Metrics server started on port {port}")
```

---

## 总结

本实施指南提供了 CapCut API MCP 服务与 Dify 工作流集成的完整解决方案，包括：

1. **完整的部署流程**: 从环境准备到服务启动的详细步骤
2. **详细的配置说明**: 各组件的配置文件和参数说明
3. **实用的代码示例**: 可直接使用的 API 调用和工作流配置
4. **全面的故障排除**: 常见问题的诊断和解决方法
5. **性能优化建议**: 提升系统性能的最佳实践
6. **安全配置指南**: 保障系统安全的配置方案

通过遵循本指南，您可以成功部署和运行 CapCut API MCP 服务，并将其无缝集成到 Dify 工作流中，实现强大的视频编辑自动化功能。

如需技术支持或有任何问题，请参考项目文档或联系技术支持团队。