# CapCut API MCP æœåŠ¡å®æ–½æŒ‡å—

## æ¦‚è¿°

æœ¬æŒ‡å—è¯¦ç»†è¯´æ˜å¦‚ä½•å°† CapCut API MCP æœåŠ¡é›†æˆåˆ° Dify å·¥ä½œæµä¸­ï¼ŒåŒ…æ‹¬å®Œæ•´çš„éƒ¨ç½²ã€é…ç½®å’Œä½¿ç”¨æµç¨‹ã€‚

## ğŸš€ å¿«é€Ÿå¼€å§‹ï¼ˆ5åˆ†é’Ÿä½“éªŒï¼‰

### æ–¹æ¡ˆé€‰æ‹©

æ ¹æ®ä½ çš„éœ€æ±‚é€‰æ‹©åˆé€‚çš„æ–¹æ¡ˆï¼š

| éœ€æ±‚åœºæ™¯ | æ¨èæ–¹æ¡ˆ | éƒ¨ç½²æ—¶é—´ | å¤æ‚åº¦ |
|---------|---------|---------|--------|
| **ä¸ªäººå­¦ä¹ /æµ‹è¯•** | å®˜æ–¹ç®€å•æ–¹æ¡ˆ | 5åˆ†é’Ÿ | â­ |
| **å°å‹é¡¹ç›®** | å®˜æ–¹ç®€å•æ–¹æ¡ˆ | 5åˆ†é’Ÿ | â­ |
| **ç”Ÿäº§ç¯å¢ƒ** | ä¼ä¸šçº§Bridgeæ–¹æ¡ˆ | 30åˆ†é’Ÿ | â­â­â­â­ |
| **é«˜å¹¶å‘éœ€æ±‚** | ä¼ä¸šçº§Bridgeæ–¹æ¡ˆ | 30åˆ†é’Ÿ | â­â­â­â­ |

### ğŸ“‹ æ–¹æ¡ˆä¸€ï¼šå®˜æ–¹ç®€å•æ–¹æ¡ˆï¼ˆæ¨èæ–°æ‰‹ï¼‰

#### ç³»ç»Ÿè¦æ±‚
- Python 3.9+
- å†…å­˜: 512MB+
- ç£ç›˜: 1GB+

#### å¿«é€Ÿéƒ¨ç½²
```bash
# 1. å¯åŠ¨CapCut APIæœåŠ¡
./service_manager.sh start

# 2. éƒ¨ç½²ç®€å•MCPæœåŠ¡å™¨
chmod +x start_simple_mcp.sh
./start_simple_mcp.sh

# 3. åœ¨Difyä¸­é…ç½®MCP
# æœåŠ¡å™¨URL: stdio://simple_mcp_server.py
```

### ğŸ“‹ æ–¹æ¡ˆäºŒï¼šä¼ä¸šçº§Bridgeæ–¹æ¡ˆï¼ˆæ¨èç”Ÿäº§ç¯å¢ƒï¼‰

#### ç³»ç»Ÿè¦æ±‚
- Python 3.11+
- å†…å­˜: 2GB+
- ç£ç›˜: 5GB+
- RedisæœåŠ¡

#### ä¸€é”®éƒ¨ç½²
```bash
# ä¸€é”®éƒ¨ç½²ä¼ä¸šçº§æ–¹æ¡ˆ
./setup_dify_integration.sh deploy

# å¯åŠ¨æ‰€æœ‰æœåŠ¡
./setup_dify_integration.sh start

# éªŒè¯éƒ¨ç½²
./setup_dify_integration.sh test
```

## ç›®å½•

1. [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
2. [ç¯å¢ƒå‡†å¤‡](#ç¯å¢ƒå‡†å¤‡)
3. [è¯¦ç»†éƒ¨ç½²](#è¯¦ç»†éƒ¨ç½²)
4. [è¯¦ç»†é…ç½®](#è¯¦ç»†é…ç½®)
5. [Dify é›†æˆ](#dify-é›†æˆ)
6. [å·¥ä½œæµè®¾è®¡](#å·¥ä½œæµè®¾è®¡)
7. [API ä½¿ç”¨ç¤ºä¾‹](#api-ä½¿ç”¨ç¤ºä¾‹)
8. [æ•…éšœæ’é™¤](#æ•…éšœæ’é™¤)
9. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
10. [å®‰å…¨é…ç½®](#å®‰å…¨é…ç½®)

## ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚   Dify å·¥ä½œæµ    â”‚â—„â”€â”€â–ºâ”‚   MCP Bridge    â”‚â—„â”€â”€â–ºâ”‚   CapCut API    â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â”‚                       â”‚                       â”‚
         â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚  Dify æ•°æ®åº“     â”‚    â”‚  Redis ç¼“å­˜      â”‚    â”‚  CapCut å¼•æ“     â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç»„ä»¶è¯´æ˜

1. **Dify å·¥ä½œæµ**: ç”¨æˆ·ç•Œé¢å’Œå·¥ä½œæµç¼–æ’
2. **MCP Bridge**: MCP åè®®æ¡¥æ¥æœåŠ¡
3. **CapCut API**: è§†é¢‘ç¼–è¾‘æ ¸å¿ƒæœåŠ¡
4. **Redis ç¼“å­˜**: ä¼šè¯å’Œæ•°æ®ç¼“å­˜
5. **æ•°æ®åº“**: æŒä¹…åŒ–å­˜å‚¨

## ç¯å¢ƒå‡†å¤‡

### ç³»ç»Ÿè¦æ±‚

- **æ“ä½œç³»ç»Ÿ**: Linux (Ubuntu 18.04+, CentOS 7+)
- **Python**: 3.8 æˆ–æ›´é«˜ç‰ˆæœ¬
- **å†…å­˜**: æœ€å°‘ 4GBï¼Œæ¨è 8GB
- **å­˜å‚¨**: æœ€å°‘ 10GB å¯ç”¨ç©ºé—´
- **ç½‘ç»œ**: ç¨³å®šçš„ç½‘ç»œè¿æ¥

### å¿…éœ€è½¯ä»¶

```bash
# æ›´æ–°ç³»ç»ŸåŒ…
sudo apt update && sudo apt upgrade -y

# å®‰è£… Python å’Œç›¸å…³å·¥å…·
sudo apt install python3 python3-pip python3-venv -y

# å®‰è£…ç³»ç»Ÿä¾èµ–
sudo apt install curl jq redis-server ffmpeg -y

# å®‰è£… Docker (å¯é€‰ï¼Œç”¨äºå®¹å™¨åŒ–éƒ¨ç½²)
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker $USER
```

### ç«¯å£è§„åˆ’

| æœåŠ¡ | ç«¯å£ | åè®® | è¯´æ˜ |
|------|------|------|------|
| CapCut API | 9000 | HTTP | ä¸»è¦ API æœåŠ¡ |
| MCP Server | 8080 | WebSocket | MCP åè®®æœåŠ¡ |
| Bridge Server | 8081 | HTTP | æ¡¥æ¥æœåŠ¡ |
| Redis | 6379 | TCP | ç¼“å­˜æœåŠ¡ |
| Dify | 5001 | HTTP | Dify API æœåŠ¡ |
| Prometheus | 9090 | HTTP | ç›‘æ§æŒ‡æ ‡ |

## è¯¦ç»†éƒ¨ç½²

### ä¸€é”®éƒ¨ç½²è„šæœ¬

```bash
# è¿›å…¥é¡¹ç›®ç›®å½•
cd /home/CapCutAPI-1.1.0

# èµ‹äºˆæ‰§è¡Œæƒé™
chmod +x setup_dify_integration.sh

# æ‰§è¡Œéƒ¨ç½² (åŸºç¡€éƒ¨ç½²)
./setup_dify_integration.sh

# æ‰§è¡Œéƒ¨ç½² (åŒ…å« Dify é›†æˆ)
./setup_dify_integration.sh \
  --dify-api "http://localhost:5001" \
  --dify-key "your-dify-api-key" \
  --mcp-port 8080 \
  --bridge-port 8081
```

### éªŒè¯éƒ¨ç½²

```bash
# æ£€æŸ¥æœåŠ¡çŠ¶æ€
./manage_integration.sh status

# æµ‹è¯• API è¿æ¥
curl http://localhost:9000/get_intro_animation_types
curl http://localhost:8081/health
curl ws://localhost:8080 # WebSocket è¿æ¥æµ‹è¯•

# è¿è¡Œé›†æˆæµ‹è¯•
./manage_integration.sh test
```

## è¯¦ç»†é…ç½®

### MCP Bridge é…ç½®

#### ä¸»é…ç½®æ–‡ä»¶ (`config/production.yaml`)

```yaml
# æœåŠ¡å™¨é…ç½®
server:
  host: "0.0.0.0"
  port: 8081
  workers: 4
  debug: false
  
# MCP æœåŠ¡å™¨é…ç½®
mcp_server:
  host: "0.0.0.0"
  port: 8080
  max_connections: 100
  timeout: 30
  heartbeat_interval: 30
  
# CapCut API é…ç½®
capcut_api:
  base_url: "http://localhost:9000"
  timeout: 60
  max_retries: 3
  retry_delay: 1
  
# Redis é…ç½®
redis:
  host: "localhost"
  port: 6379
  db: 0
  password: ""
  max_connections: 20
  
# æ—¥å¿—é…ç½®
logging:
  level: "INFO"
  file: "logs/bridge.log"
  max_size: "100MB"
  backup_count: 5
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  
# ç›‘æ§é…ç½®
monitoring:
  enabled: true
  metrics_port: 9090
  health_check_interval: 30
  
# å®‰å…¨é…ç½®
security:
  api_key_required: false
  api_key: ""
  cors_enabled: true
  cors_origins: ["*"]
  rate_limit:
    enabled: true
    requests_per_minute: 100
    burst_size: 20
```

#### å¼€å‘ç¯å¢ƒé…ç½® (`config/development.yaml`)

```yaml
# ç»§æ‰¿ç”Ÿäº§é…ç½®å¹¶è¦†ç›–ç‰¹å®šè®¾ç½®
server:
  debug: true
  
logging:
  level: "DEBUG"
  
security:
  cors_origins: ["http://localhost:3000", "http://localhost:5001"]
```

### Dify é›†æˆé…ç½®

#### é›†æˆé…ç½®æ–‡ä»¶ (`config/dify_integration.yaml`)

```yaml
# Dify è¿æ¥é…ç½®
dify:
  api_base_url: "http://localhost:5001"
  api_key: ""  # ä»ç¯å¢ƒå˜é‡è·å–
  timeout: 30
  max_retries: 3
  
# MCP æœåŠ¡å™¨ä¿¡æ¯
mcp_server:
  name: "CapCut API MCP Server"
  description: "CapCut è§†é¢‘ç¼–è¾‘ API çš„ MCP æœåŠ¡å™¨"
  url: "ws://localhost:8080"
  version: "1.0.0"
  capabilities:
    tools: true
    resources: true
    prompts: false
  
# å·¥ä½œæµé…ç½®
workflows:
  templates_dir: "templates"
  auto_deploy: false
  backup_enabled: true
  
# é›†æˆè®¾ç½®
integration:
  auto_register: true
  health_check_interval: 60
  retry_count: 3
  sync_interval: 300
```

## Dify é›†æˆ

### æ‰‹åŠ¨æ³¨å†Œ MCP æœåŠ¡å™¨

1. **ç™»å½• Dify ç®¡ç†ç•Œé¢**
   ```
   http://localhost:5001/admin
   ```

2. **å¯¼èˆªåˆ° MCP æœåŠ¡å™¨è®¾ç½®**
   - ç‚¹å‡»å·¦ä¾§èœå• "è®¾ç½®"
   - é€‰æ‹© "æ¨¡å‹ä¾›åº”å•†"
   - ç‚¹å‡» "MCP æœåŠ¡å™¨" æ ‡ç­¾

3. **æ·»åŠ æ–°çš„ MCP æœåŠ¡å™¨**
   - ç‚¹å‡» "æ·»åŠ  MCP æœåŠ¡å™¨" æŒ‰é’®
   - å¡«å†™æœåŠ¡å™¨ä¿¡æ¯ï¼š
     ```
     åç§°: CapCut API MCP Server
     URL: ws://localhost:8080
     æè¿°: CapCut è§†é¢‘ç¼–è¾‘ API çš„ MCP æœåŠ¡å™¨
     ```

4. **æµ‹è¯•è¿æ¥**
   - ç‚¹å‡» "æµ‹è¯•è¿æ¥" æŒ‰é’®
   - ç¡®è®¤è¿æ¥çŠ¶æ€ä¸º "å·²è¿æ¥"
   - æŸ¥çœ‹å¯ç”¨å·¥å…·åˆ—è¡¨

5. **ä¿å­˜é…ç½®**
   - ç‚¹å‡» "ä¿å­˜" æŒ‰é’®
   - ç¡®è®¤æœåŠ¡å™¨å·²æ·»åŠ åˆ°åˆ—è¡¨ä¸­

### è‡ªåŠ¨æ³¨å†Œè„šæœ¬

```python
# ä½¿ç”¨ Python è„šæœ¬è‡ªåŠ¨æ³¨å†Œ
import requests
import json

def register_mcp_server():
    dify_api_url = "http://localhost:5001"
    api_key = "your-dify-api-key"
    
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    
    server_config = {
        "name": "CapCut API MCP Server",
        "url": "ws://localhost:8080",
        "description": "CapCut è§†é¢‘ç¼–è¾‘ API çš„ MCP æœåŠ¡å™¨",
        "capabilities": {
            "tools": True,
            "resources": True
        }
    }
    
    response = requests.post(
        f"{dify_api_url}/api/v1/mcp-servers",
        headers=headers,
        json=server_config
    )
    
    if response.status_code == 201:
        print("MCP æœåŠ¡å™¨æ³¨å†ŒæˆåŠŸ")
        return response.json()
    else:
        print(f"æ³¨å†Œå¤±è´¥: {response.text}")
        return None

# æ‰§è¡Œæ³¨å†Œ
if __name__ == "__main__":
    register_mcp_server()
```

## å·¥ä½œæµè®¾è®¡

### åŸºç¡€è§†é¢‘ç”Ÿæˆå·¥ä½œæµ

#### å·¥ä½œæµç»“æ„

```yaml
name: "CapCut è§†é¢‘ç”Ÿæˆå·¥ä½œæµ"
description: "ä½¿ç”¨ CapCut API è‡ªåŠ¨ç”Ÿæˆè§†é¢‘"
version: "1.0.0"

nodes:
  - id: "start"
    type: "start"
    name: "å¼€å§‹"
    
  - id: "create_draft"
    type: "tool"
    name: "åˆ›å»ºè‰ç¨¿"
    tool: "create_draft"
    inputs:
      title: "{{ inputs.video_title }}"
      description: "{{ inputs.video_description }}"
    
  - id: "add_video"
    type: "tool"
    name: "æ·»åŠ è§†é¢‘"
    tool: "add_video"
    inputs:
      draft_id: "{{ create_draft.draft_id }}"
      video_url: "{{ inputs.video_url }}"
      start_time: 0
      duration: "{{ inputs.video_duration }}"
    
  - id: "add_text"
    type: "tool"
    name: "æ·»åŠ æ ‡é¢˜"
    tool: "add_text"
    inputs:
      draft_id: "{{ create_draft.draft_id }}"
      text: "{{ inputs.title_text }}"
      font_size: 48
      position: "center"
    
  - id: "add_effect"
    type: "tool"
    name: "æ·»åŠ ç‰¹æ•ˆ"
    tool: "add_effect"
    inputs:
      draft_id: "{{ create_draft.draft_id }}"
      effect_type: "{{ inputs.effect_type }}"
      intensity: 0.8
    
  - id: "save_draft"
    type: "tool"
    name: "ä¿å­˜è‰ç¨¿"
    tool: "save_draft"
    inputs:
      draft_id: "{{ create_draft.draft_id }}"
    
  - id: "end"
    type: "end"
    name: "ç»“æŸ"
    outputs:
      draft_id: "{{ create_draft.draft_id }}"
      video_url: "{{ save_draft.video_url }}"

connections:
  - from: "start"
    to: "create_draft"
  - from: "create_draft"
    to: "add_video"
  - from: "add_video"
    to: "add_text"
  - from: "add_text"
    to: "add_effect"
  - from: "add_effect"
    to: "save_draft"
  - from: "save_draft"
    to: "end"
```

#### è¾“å…¥å‚æ•°

```json
{
  "video_title": "æˆ‘çš„è§†é¢‘æ ‡é¢˜",
  "video_description": "è§†é¢‘æè¿°ä¿¡æ¯",
  "video_url": "https://example.com/video.mp4",
  "video_duration": 30,
  "title_text": "æ¬¢è¿è§‚çœ‹",
  "effect_type": "fade_in"
}
```

### é«˜çº§æ‰¹é‡å¤„ç†å·¥ä½œæµ

#### å·¥ä½œæµç‰¹æ€§

- æ”¯æŒæ‰¹é‡è§†é¢‘å¤„ç†
- è‡ªåŠ¨é”™è¯¯é‡è¯•
- è¿›åº¦è·Ÿè¸ª
- ç»“æœæ±‡æ€»

#### èŠ‚ç‚¹é…ç½®ç¤ºä¾‹

```yaml
# æ‰¹é‡å¤„ç†èŠ‚ç‚¹
- id: "batch_process"
  type: "loop"
  name: "æ‰¹é‡å¤„ç†è§†é¢‘"
  loop_variable: "video_item"
  loop_data: "{{ inputs.video_list }}"
  nodes:
    - id: "process_single_video"
      type: "subflow"
      name: "å¤„ç†å•ä¸ªè§†é¢‘"
      subflow: "single_video_workflow"
      inputs:
        video_url: "{{ video_item.url }}"
        title: "{{ video_item.title }}"
      error_handling:
        retry_count: 3
        retry_delay: 5
        on_error: "continue"
```

## API ä½¿ç”¨ç¤ºä¾‹

### åˆ›å»ºè§†é¢‘è‰ç¨¿

```python
import asyncio
import websockets
import json

async def create_video_draft():
    uri = "ws://localhost:8080"
    
    async with websockets.connect(uri) as websocket:
        # å‘é€åˆ›å»ºè‰ç¨¿è¯·æ±‚
        request = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "tools/call",
            "params": {
                "name": "create_draft",
                "arguments": {
                    "title": "æˆ‘çš„ç¬¬ä¸€ä¸ªè§†é¢‘",
                    "description": "ä½¿ç”¨ CapCut API åˆ›å»ºçš„è§†é¢‘"
                }
            }
        }
        
        await websocket.send(json.dumps(request))
        response = await websocket.recv()
        result = json.loads(response)
        
        print(f"è‰ç¨¿åˆ›å»ºæˆåŠŸ: {result}")
        return result["result"]["draft_id"]

# è¿è¡Œç¤ºä¾‹
draft_id = asyncio.run(create_video_draft())
```

### æ·»åŠ è§†é¢‘å†…å®¹

```python
async def add_video_content(draft_id, video_url):
    uri = "ws://localhost:8080"
    
    async with websockets.connect(uri) as websocket:
        request = {
            "jsonrpc": "2.0",
            "id": 2,
            "method": "tools/call",
            "params": {
                "name": "add_video",
                "arguments": {
                    "draft_id": draft_id,
                    "video_url": video_url,
                    "start_time": 0,
                    "duration": 30,
                    "position": {
                        "x": 0,
                        "y": 0,
                        "width": 1920,
                        "height": 1080
                    }
                }
            }
        }
        
        await websocket.send(json.dumps(request))
        response = await websocket.recv()
        result = json.loads(response)
        
        print(f"è§†é¢‘æ·»åŠ æˆåŠŸ: {result}")
        return result

# ä½¿ç”¨ç¤ºä¾‹
video_url = "https://example.com/sample.mp4"
result = asyncio.run(add_video_content(draft_id, video_url))
```

### æ‰¹é‡æ“ä½œç¤ºä¾‹

```python
async def batch_create_videos(video_configs):
    """æ‰¹é‡åˆ›å»ºè§†é¢‘"""
    results = []
    
    for config in video_configs:
        try:
            # åˆ›å»ºè‰ç¨¿
            draft_id = await create_video_draft()
            
            # æ·»åŠ è§†é¢‘
            await add_video_content(draft_id, config["video_url"])
            
            # æ·»åŠ æ–‡æœ¬
            await add_text_overlay(draft_id, config["title"])
            
            # ä¿å­˜è‰ç¨¿
            video_url = await save_draft(draft_id)
            
            results.append({
                "draft_id": draft_id,
                "video_url": video_url,
                "status": "success"
            })
            
        except Exception as e:
            results.append({
                "config": config,
                "error": str(e),
                "status": "failed"
            })
    
    return results

# æ‰¹é‡å¤„ç†é…ç½®
video_configs = [
    {
        "video_url": "https://example.com/video1.mp4",
        "title": "è§†é¢‘1æ ‡é¢˜"
    },
    {
        "video_url": "https://example.com/video2.mp4",
        "title": "è§†é¢‘2æ ‡é¢˜"
    }
]

# æ‰§è¡Œæ‰¹é‡å¤„ç†
results = asyncio.run(batch_create_videos(video_configs))
```

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆ

#### 1. MCP æœåŠ¡å™¨è¿æ¥å¤±è´¥

**ç—‡çŠ¶**: Dify æ— æ³•è¿æ¥åˆ° MCP æœåŠ¡å™¨

**å¯èƒ½åŸå› **:
- MCP æœåŠ¡å™¨æœªå¯åŠ¨
- ç«¯å£è¢«å ç”¨
- é˜²ç«å¢™é˜»æ­¢è¿æ¥
- ç½‘ç»œé…ç½®é—®é¢˜

**è§£å†³æ­¥éª¤**:
```bash
# æ£€æŸ¥æœåŠ¡çŠ¶æ€
./manage_integration.sh status

# æ£€æŸ¥ç«¯å£å ç”¨
netstat -tlnp | grep 8080

# æŸ¥çœ‹æœåŠ¡æ—¥å¿—
./manage_integration.sh logs mcp

# é‡å¯æœåŠ¡
./manage_integration.sh restart

# æµ‹è¯•è¿æ¥
curl -v ws://localhost:8080
```

#### 2. API è°ƒç”¨è¶…æ—¶

**ç—‡çŠ¶**: å·¥å…·è°ƒç”¨æ—¶å‡ºç°è¶…æ—¶é”™è¯¯

**å¯èƒ½åŸå› **:
- CapCut API æœåŠ¡å“åº”æ…¢
- ç½‘ç»œå»¶è¿Ÿ
- èµ„æºä¸è¶³

**è§£å†³æ­¥éª¤**:
```bash
# æ£€æŸ¥ CapCut API çŠ¶æ€
curl http://localhost:9000/get_intro_animation_types

# æŸ¥çœ‹ç³»ç»Ÿèµ„æº
top
df -h

# è°ƒæ•´è¶…æ—¶é…ç½®
# ç¼–è¾‘ config/production.yaml
# å¢åŠ  timeout å€¼
```

#### 3. å·¥ä½œæµæ‰§è¡Œå¤±è´¥

**ç—‡çŠ¶**: Dify å·¥ä½œæµæ‰§è¡Œæ—¶æŠ¥é”™

**å¯èƒ½åŸå› **:
- å‚æ•°é…ç½®é”™è¯¯
- å·¥å…·è°ƒç”¨å¤±è´¥
- æ•°æ®æ ¼å¼ä¸åŒ¹é…

**è§£å†³æ­¥éª¤**:
```bash
# æŸ¥çœ‹è¯¦ç»†æ—¥å¿—
./manage_integration.sh logs bridge

# æµ‹è¯•å•ä¸ªå·¥å…·
./manage_integration.sh test

# éªŒè¯å‚æ•°æ ¼å¼
# æ£€æŸ¥å·¥ä½œæµé…ç½®
```

### æ—¥å¿—åˆ†æ

#### æ—¥å¿—çº§åˆ«è¯´æ˜

- **DEBUG**: è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯
- **INFO**: ä¸€èˆ¬ä¿¡æ¯
- **WARNING**: è­¦å‘Šä¿¡æ¯
- **ERROR**: é”™è¯¯ä¿¡æ¯
- **CRITICAL**: ä¸¥é‡é”™è¯¯

#### å¸¸è§é”™è¯¯æ¨¡å¼

```bash
# è¿æ¥é”™è¯¯
grep "Connection" logs/mcp_server.log

# è¶…æ—¶é”™è¯¯
grep "timeout" logs/bridge.log

# API é”™è¯¯
grep "API Error" logs/bridge.log

# è®¤è¯é”™è¯¯
grep "Authentication" logs/bridge.log
```

### æ€§èƒ½è°ƒä¼˜

#### ç³»ç»Ÿèµ„æºç›‘æ§

```bash
# CPU ä½¿ç”¨ç‡
top -p $(pgrep -f "mcp_server|bridge_server")

# å†…å­˜ä½¿ç”¨
ps aux | grep -E "mcp_server|bridge_server"

# ç½‘ç»œè¿æ¥
netstat -an | grep -E "8080|8081"

# ç£ç›˜ I/O
iotop
```

#### é…ç½®ä¼˜åŒ–

```yaml
# å¢åŠ å·¥ä½œè¿›ç¨‹æ•°
server:
  workers: 8  # æ ¹æ® CPU æ ¸å¿ƒæ•°è°ƒæ•´

# ä¼˜åŒ–è¿æ¥æ± 
mcp_server:
  max_connections: 200
  
redis:
  max_connections: 50

# è°ƒæ•´è¶…æ—¶è®¾ç½®
capcut_api:
  timeout: 120
  max_retries: 5
```

## æ€§èƒ½ä¼˜åŒ–

### ç¼“å­˜ç­–ç•¥

#### Redis ç¼“å­˜é…ç½®

```yaml
# ç¼“å­˜é…ç½®
cache:
  enabled: true
  default_ttl: 3600  # 1å°æ—¶
  max_memory: "256mb"
  
  # ç¼“å­˜ç­–ç•¥
  policies:
    draft_info: 1800    # 30åˆ†é’Ÿ
    video_metadata: 3600 # 1å°æ—¶
    user_sessions: 7200  # 2å°æ—¶
```

#### åº”ç”¨å±‚ç¼“å­˜

```python
from functools import lru_cache
import redis

# å†…å­˜ç¼“å­˜
@lru_cache(maxsize=1000)
def get_animation_types():
    """ç¼“å­˜åŠ¨ç”»ç±»å‹æ•°æ®"""
    return fetch_animation_types_from_api()

# Redis ç¼“å­˜
redis_client = redis.Redis(host='localhost', port=6379, db=0)

def cached_api_call(key, func, ttl=3600):
    """é€šç”¨ Redis ç¼“å­˜è£…é¥°å™¨"""
    cached_result = redis_client.get(key)
    if cached_result:
        return json.loads(cached_result)
    
    result = func()
    redis_client.setex(key, ttl, json.dumps(result))
    return result
```

### è¿æ¥æ± ä¼˜åŒ–

```python
import asyncio
import aiohttp
from aiohttp_session import setup
from aiohttp_session.redis_storage import RedisStorage

class ConnectionManager:
    def __init__(self):
        self.http_session = None
        self.redis_pool = None
        
    async def initialize(self):
        # HTTP è¿æ¥æ± 
        connector = aiohttp.TCPConnector(
            limit=100,
            limit_per_host=20,
            ttl_dns_cache=300,
            use_dns_cache=True
        )
        
        self.http_session = aiohttp.ClientSession(
            connector=connector,
            timeout=aiohttp.ClientTimeout(total=30)
        )
        
        # Redis è¿æ¥æ± 
        self.redis_pool = aioredis.ConnectionPool.from_url(
            "redis://localhost:6379",
            max_connections=20
        )
```

### å¼‚æ­¥å¤„ç†ä¼˜åŒ–

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AsyncTaskManager:
    def __init__(self, max_workers=10):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.semaphore = asyncio.Semaphore(max_workers)
        
    async def execute_task(self, func, *args, **kwargs):
        """å¼‚æ­¥æ‰§è¡Œä»»åŠ¡"""
        async with self.semaphore:
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(
                self.executor, func, *args, **kwargs
            )
    
    async def batch_execute(self, tasks):
        """æ‰¹é‡æ‰§è¡Œä»»åŠ¡"""
        return await asyncio.gather(*tasks, return_exceptions=True)
```

## å®‰å…¨é…ç½®

### API å¯†é’¥ç®¡ç†

#### ç¯å¢ƒå˜é‡é…ç½®

```bash
# .env æ–‡ä»¶
DIFY_API_KEY=your-secret-api-key
MCP_BRIDGE_API_KEY=your-bridge-api-key
REDIS_PASSWORD=your-redis-password
JWT_SECRET_KEY=your-jwt-secret

# åŠ è½½ç¯å¢ƒå˜é‡
export $(cat .env | xargs)
```

#### å¯†é’¥è½®æ¢ç­–ç•¥

```python
import os
import hashlib
from datetime import datetime, timedelta

class APIKeyManager:
    def __init__(self):
        self.current_key = os.getenv('MCP_BRIDGE_API_KEY')
        self.key_rotation_interval = timedelta(days=30)
        
    def generate_new_key(self):
        """ç”Ÿæˆæ–°çš„ API å¯†é’¥"""
        timestamp = datetime.now().isoformat()
        random_data = os.urandom(32)
        
        key_data = f"{timestamp}{random_data.hex()}"
        return hashlib.sha256(key_data.encode()).hexdigest()
    
    def rotate_key(self):
        """è½®æ¢ API å¯†é’¥"""
        new_key = self.generate_new_key()
        
        # æ›´æ–°é…ç½®
        self.update_key_in_config(new_key)
        
        # é€šçŸ¥ç›¸å…³æœåŠ¡
        self.notify_key_rotation(new_key)
        
        return new_key
```

### è®¿é—®æ§åˆ¶

#### IP ç™½åå•

```yaml
# å®‰å…¨é…ç½®
security:
  ip_whitelist:
    enabled: true
    allowed_ips:
      - "127.0.0.1"
      - "10.0.0.0/8"
      - "172.16.0.0/12"
      - "192.168.0.0/16"
  
  rate_limiting:
    enabled: true
    requests_per_minute: 100
    burst_size: 20
    
  cors:
    enabled: true
    allowed_origins:
      - "http://localhost:3000"
      - "http://localhost:5001"
    allowed_methods: ["GET", "POST", "PUT", "DELETE"]
    allowed_headers: ["Content-Type", "Authorization"]
```

#### JWT è®¤è¯

```python
import jwt
from datetime import datetime, timedelta

class JWTManager:
    def __init__(self, secret_key):
        self.secret_key = secret_key
        self.algorithm = "HS256"
        
    def generate_token(self, user_id, expires_in=3600):
        """ç”Ÿæˆ JWT ä»¤ç‰Œ"""
        payload = {
            "user_id": user_id,
            "exp": datetime.utcnow() + timedelta(seconds=expires_in),
            "iat": datetime.utcnow()
        }
        
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token):
        """éªŒè¯ JWT ä»¤ç‰Œ"""
        try:
            payload = jwt.decode(
                token, self.secret_key, algorithms=[self.algorithm]
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise Exception("ä»¤ç‰Œå·²è¿‡æœŸ")
        except jwt.InvalidTokenError:
            raise Exception("æ— æ•ˆä»¤ç‰Œ")
```

### HTTPS é…ç½®

#### SSL è¯ä¹¦é…ç½®

```yaml
# HTTPS é…ç½®
ssl:
  enabled: true
  cert_file: "/path/to/certificate.crt"
  key_file: "/path/to/private.key"
  ca_file: "/path/to/ca-bundle.crt"
  
  # SSL é€‰é¡¹
  ssl_version: "TLSv1.2"
  ciphers: "ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS"
```

#### åå‘ä»£ç†é…ç½® (Nginx)

```nginx
server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    
    # MCP Bridge ä»£ç†
    location /mcp/ {
        proxy_pass http://localhost:8081/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # WebSocket ä»£ç†
    location /ws/ {
        proxy_pass http://localhost:8080/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

## ç›‘æ§å’Œç»´æŠ¤

### å¥åº·æ£€æŸ¥

```python
import asyncio
import aiohttp
from datetime import datetime

class HealthChecker:
    def __init__(self):
        self.services = {
            "capcut_api": "http://localhost:9000/health",
            "mcp_server": "ws://localhost:8080",
            "bridge_server": "http://localhost:8081/health",
            "redis": "redis://localhost:6379"
        }
    
    async def check_service_health(self, name, url):
        """æ£€æŸ¥å•ä¸ªæœåŠ¡å¥åº·çŠ¶æ€"""
        try:
            if url.startswith("http"):
                async with aiohttp.ClientSession() as session:
                    async with session.get(url, timeout=5) as response:
                        return {
                            "service": name,
                            "status": "healthy" if response.status == 200 else "unhealthy",
                            "response_time": response.headers.get("X-Response-Time"),
                            "timestamp": datetime.now().isoformat()
                        }
            elif url.startswith("ws"):
                # WebSocket å¥åº·æ£€æŸ¥
                return await self.check_websocket_health(name, url)
            elif url.startswith("redis"):
                # Redis å¥åº·æ£€æŸ¥
                return await self.check_redis_health(name, url)
                
        except Exception as e:
            return {
                "service": name,
                "status": "unhealthy",
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }
    
    async def check_all_services(self):
        """æ£€æŸ¥æ‰€æœ‰æœåŠ¡å¥åº·çŠ¶æ€"""
        tasks = [
            self.check_service_health(name, url)
            for name, url in self.services.items()
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results
```

### æ—¥å¿—èšåˆ

```python
import logging
import json
from logging.handlers import RotatingFileHandler
from datetime import datetime

class StructuredLogger:
    def __init__(self, name, log_file, max_size=100*1024*1024):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.INFO)
        
        # åˆ›å»ºè½®è½¬æ–‡ä»¶å¤„ç†å™¨
        handler = RotatingFileHandler(
            log_file, maxBytes=max_size, backupCount=5
        )
        
        # è®¾ç½®æ ¼å¼åŒ–å™¨
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        
        self.logger.addHandler(handler)
    
    def log_structured(self, level, message, **kwargs):
        """è®°å½•ç»“æ„åŒ–æ—¥å¿—"""
        log_data = {
            "timestamp": datetime.now().isoformat(),
            "message": message,
            "level": level,
            **kwargs
        }
        
        getattr(self.logger, level.lower())(json.dumps(log_data))
    
    def log_api_call(self, method, endpoint, status_code, response_time):
        """è®°å½• API è°ƒç”¨æ—¥å¿—"""
        self.log_structured(
            "INFO",
            "API call completed",
            method=method,
            endpoint=endpoint,
            status_code=status_code,
            response_time=response_time
        )
```

### æ€§èƒ½æŒ‡æ ‡æ”¶é›†

```python
import time
import psutil
from prometheus_client import Counter, Histogram, Gauge, start_http_server

# Prometheus æŒ‡æ ‡
api_requests_total = Counter(
    'api_requests_total',
    'Total API requests',
    ['method', 'endpoint', 'status']
)

api_request_duration = Histogram(
    'api_request_duration_seconds',
    'API request duration',
    ['method', 'endpoint']
)

active_connections = Gauge(
    'active_connections',
    'Number of active connections'
)

system_memory_usage = Gauge(
    'system_memory_usage_bytes',
    'System memory usage'
)

class MetricsCollector:
    def __init__(self):
        self.start_time = time.time()
        
    def record_api_request(self, method, endpoint, status_code, duration):
        """è®°å½• API è¯·æ±‚æŒ‡æ ‡"""
        api_requests_total.labels(
            method=method,
            endpoint=endpoint,
            status=status_code
        ).inc()
        
        api_request_duration.labels(
            method=method,
            endpoint=endpoint
        ).observe(duration)
    
    def update_system_metrics(self):
        """æ›´æ–°ç³»ç»ŸæŒ‡æ ‡"""
        memory = psutil.virtual_memory()
        system_memory_usage.set(memory.used)
        
        # æ›´æ–°å…¶ä»–ç³»ç»ŸæŒ‡æ ‡
        cpu_usage = psutil.cpu_percent()
        disk_usage = psutil.disk_usage('/').percent
        
    def start_metrics_server(self, port=9090):
        """å¯åŠ¨æŒ‡æ ‡æœåŠ¡å™¨"""
        start_http_server(port)
        print(f"Metrics server started on port {port}")
```

---

## æ€»ç»“

æœ¬å®æ–½æŒ‡å—æä¾›äº† CapCut API MCP æœåŠ¡ä¸ Dify å·¥ä½œæµé›†æˆçš„å®Œæ•´è§£å†³æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š

1. **å®Œæ•´çš„éƒ¨ç½²æµç¨‹**: ä»ç¯å¢ƒå‡†å¤‡åˆ°æœåŠ¡å¯åŠ¨çš„è¯¦ç»†æ­¥éª¤
2. **è¯¦ç»†çš„é…ç½®è¯´æ˜**: å„ç»„ä»¶çš„é…ç½®æ–‡ä»¶å’Œå‚æ•°è¯´æ˜
3. **å®ç”¨çš„ä»£ç ç¤ºä¾‹**: å¯ç›´æ¥ä½¿ç”¨çš„ API è°ƒç”¨å’Œå·¥ä½œæµé…ç½®
4. **å…¨é¢çš„æ•…éšœæ’é™¤**: å¸¸è§é—®é¢˜çš„è¯Šæ–­å’Œè§£å†³æ–¹æ³•
5. **æ€§èƒ½ä¼˜åŒ–å»ºè®®**: æå‡ç³»ç»Ÿæ€§èƒ½çš„æœ€ä½³å®è·µ
6. **å®‰å…¨é…ç½®æŒ‡å—**: ä¿éšœç³»ç»Ÿå®‰å…¨çš„é…ç½®æ–¹æ¡ˆ

é€šè¿‡éµå¾ªæœ¬æŒ‡å—ï¼Œæ‚¨å¯ä»¥æˆåŠŸéƒ¨ç½²å’Œè¿è¡Œ CapCut API MCP æœåŠ¡ï¼Œå¹¶å°†å…¶æ— ç¼é›†æˆåˆ° Dify å·¥ä½œæµä¸­ï¼Œå®ç°å¼ºå¤§çš„è§†é¢‘ç¼–è¾‘è‡ªåŠ¨åŒ–åŠŸèƒ½ã€‚

å¦‚éœ€æŠ€æœ¯æ”¯æŒæˆ–æœ‰ä»»ä½•é—®é¢˜ï¼Œè¯·å‚è€ƒé¡¹ç›®æ–‡æ¡£æˆ–è”ç³»æŠ€æœ¯æ”¯æŒå›¢é˜Ÿã€‚